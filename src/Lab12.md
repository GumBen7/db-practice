---
title: Лабораторная работа 12. Нормализация, ER-модель и импорт данных
---

[Архив с данными для импорта](assets/lab/DE_norm.zip)

[К списку лабораторных >>>](../README.md)

---

### Задание

1. Привести структуру таблиц к 3НФ
2. Нарисовать диаграмму в MS Visio (логическая модель данных, которая про таблички)
3. Со звёздочкой #1. Подготовить Excel-файлы для импорта
4. Со звёздочкой #2. Написать скрипт для создания таблиц

! Сами таблицы в БД можно не создавать

---

### [Нормализация](https://habr.com/ru/post/254773/)


Нормальная форма — требование, предъявляемое к структуре таблиц в теории реляционных баз данных 
для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).

Метод нормальных форм (НФ) состоит в сборе информации о объектах решения задачи в рамках одного отношения 
и последующей декомпозиции этого отношения на несколько взаимосвязанных отношений на основе процедур нормализации отношений.

Цель нормализации: исключить избыточное дублирование данных, которое является причиной аномалий, 
возникших при добавлении, редактировании и удалении кортежей(строк таблицы).

Аномалией называется такая ситуация в таблице БД, которая приводит к противоречию в БД 
либо существенно усложняет обработку БД. Причиной является излишнее дублирование данных в таблице, 
которое вызывается наличием функциональных зависимостей от не ключевых атрибутов.

Аномалии-модификации проявляются в том, что изменение одних данных может повлечь просмотр всей таблицы 
и соответствующее изменение некоторых записей таблицы.

Аномалии-удаления — при удалении какого либо кортежа из таблицы может пропасть информация, 
которая не связана на прямую с удаляемой записью.

Аномалии-добавления возникают, когда информацию в таблицу нельзя поместить, пока она не полная, 
либо вставка записи требует дополнительного просмотра таблицы.

### Первая нормальная форма

Отношение находится в 1НФ, если все его атрибуты являются простыми, 
все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице.

Например, есть таблица «Автомобили»:

<img src="assets/Screenshot%20from%202023-10-18%2012-53-59.png" alt="drawing" width="300"/>

Нарушение нормализации 1НФ происходит в моделях BMW, т.к. в одной ячейке содержится список из 3 элементов: M5, X5M, M1, 
т.е. он не является атомарным. Преобразуем таблицу к 1НФ:

<img src="assets/Screenshot%20from%202023-10-18%2012-54-35.png" alt="drawing" width="300"/>

Чтобы преобразовать сущность в первую нормальную форму, следует исключить повторяющиеся группы значений и добиться того, 
чтобы каждый атрибут содержал только одно значение, списки значений не допускаются.
Другими словами, каждый атрибут в сущности должен храниться только в одном экземпляре.


### Вторая нормальная форма

Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от Первичного Ключа(ПК).

Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, 
от которого можно также вывести данную функциональную зависимость.

То есть, таблица во второй нормальной форме содержит только те данные, которые к ней относятся. 
Значения не ключевых атрибутов сущности зависят от первичного ключа. Если более точно, то атрибуты зависят от первичного ключа, от всего первичного ключа и только от первичного ключа.
Для соответствия второй нормальной форме сущности должны быть в первой нормальной форме.

Например, дана таблица:

<img src="assets/Screenshot%20from%202023-10-18%2012-55-18.png" alt="drawing" width="300"/>

Таблица находится в первой нормальной форме, но не во второй. Цена машины зависит от модели и фирмы. 
Скидка зависят от фирмы, то есть зависимость от первичного ключа неполная. 

Исправляется это путем декомпозиции на два отношения, в которых не ключевые атрибуты зависят от ПК.

<img src="assets/Screenshot%20from%202023-10-18%2012-56-12.png" alt="drawing" width="300"/>

<img src="assets/Screenshot%20from%202023-10-18%2012-56-18.png" alt="drawing" width="300"/>

### Третья нормальная форма

Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа. 
Проще говоря, второе правило требует выносить все не ключевые поля, 
содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы.

В третьей нормальной форме исключаются атрибуты, не зависящие от всего ключа. 
Любая сущность, находящаяся в третьей нормальной форме, находится также и во второй. Это самая распространенная форма базы данных.
В третьей нормальной форме каждый атрибут зависит от ключа, от всего ключа и ни от чего, кроме ключа.

Рассмотрим таблицу:

<img src="assets/Screenshot%20from%202023-10-18%2012-56-55.png" alt="drawing" width="300"/>

Таблица находится во 2НФ, но не в 3НФ.
В отношении атрибут «Модель» является первичным ключом. Личных телефонов у автомобилей нет, 
и телефон зависит исключительно от магазина.

Таким образом, в отношении существуют следующие функциональные зависимости: 
Модель → Магазин, Магазин → Телефон, Модель → Телефон.

Зависимость Модель → Телефон является транзитивной, следовательно, отношение не находится в 3НФ.
В результате разделения исходного отношения получаются два отношения, находящиеся в 3НФ:

<img src="assets/Screenshot%20from%202023-10-18%2012-57-42.png" alt="drawing" width="300"/>

<img src="assets/Screenshot%20from%202023-10-18%2012-57-49.png" alt="drawing" width="300"/>

### Нормальная форма Бойса-Кодда

Рассмотрим следующий пример схемы отношения:

СОТРУДНИКИ-ПРОЕКТЫ (СОТР_НОМЕР, СОТР_ИМЯ, ПРО_НОМЕР, СОТР_ЗАДАН) 

Возможные ключи: 

СОТР_НОМЕР, ПРО_НОМЕР 
СОТР_ИМЯ, ПРО_НОМЕР 

Функциональные зависимости: 

СОТР_НОМЕР -> CОТР_ИМЯ 
СОТР_НОМЕР -> ПРО_НОМЕР 
СОТР_ИМЯ -> CОТР_НОМЕР 
СОТР_ИМЯ -> ПРО_НОМЕР 
СОТР_НОМЕР, ПРО_НОМЕР -> CОТР_ЗАДАН 
СОТР_ИМЯ, ПРО_НОМЕР -> CОТР_ЗАДАН 

В этом примере мы предполагаем, что личность сотрудника полностью определяется как его номером, 
ак и именем (это снова не очень жизненное предположение, но достаточное для примера). 

В соответствии с определением, отношение СОТРУДНИКИ-ПРОЕКТЫ находится в 3NF. 
Однако тот факт, что имеются функциональные зависимости атрибутов отношения от атрибута, 
являющегося частью первичного ключа, приводит к аномалиям. 
Например, для того, чтобы изменить имя сотрудника с данным номером согласованным образом, нам потребуется модифицировать все кортежи, включающие его номер. 

#### Детерминант

Детерминант - любой атрибут, от которого полностью функционально зависит некоторый другой атрибут. 

#### Нормальная форма Бойса-Кодда

Отношение R находится в нормальной форме Бойса-Кодда (BCNF) в том и только в том случае, если каждый детерминант является возможным ключом. 

Очевидно, что это требование не выполнено для отношения СОТРУДНИКИ-ПРОЕКТЫ. Можно произвести его декомпозицию к отношениям СОТРУДНИКИ и СОТРУДНИКИ-ПРОЕКТЫ: 
СОТРУДНИКИ (СОТР_НОМЕР, СОТР_ИМЯ) 

Возможные ключи: 

СОТР_НОМЕР 
СОТР_ИМЯ 

Функциональные зависимости:

СОТР_НОМЕР -> CОТР_ИМЯ 
СОТР_ИМЯ -> СОТР_НОМЕР 
СОТРУДНИКИ-ПРОЕКТЫ (СОТР_НОМЕР, ПРО_НОМЕР, СОТР_ЗАДАН) 

Возможный ключ: 

СОТР_НОМЕР, ПРО_НОМЕР 

Функциональные зависимости: 

СОТР_НОМЕР, ПРО_НОМЕР -> CОТР_ЗАДАН 

Возможна альтернативная декомпозиция, если выбрать за основу СОТР_ИМЯ. 
В обоих случаях получаемые отношения СОТРУДНИКИ и СОТРУДНИКИ-ПРОЕКТЫ находятся в BCNF, и им не свойственны отмеченные аномалии. 

### Четвертая нормальная форма

Рассмотрим пример следующей схемы отношения: 

ПРОЕКТЫ (ПРО_НОМЕР,ПРО_СОТР, ПРО_ЗАДАН) 

Отношение ПРОЕКТЫ содержит номера проектов, для каждого проекта список сотрудников, 
которые могут выполнять проект, и список заданий, предусматриваемых проектом. 
Сотрудники могут участвовать в нескольких проектах, и разные проекты могут включать одинаковые задания. 
Каждый кортеж отношения связывает некоторый проект с сотрудником, участвующим в этом проекте, 
и заданием, который сотрудник выполняет в рамках данного проекта 
(мы предполагаем, что любой сотрудник, участвующий в проекте, выполняет все задания, предусмотренные этим проектом). 

По причине сформулированных выше условий единственным возможным ключем отношения является составной атрибут 
ПРО_НОМЕР, ПРО_СОТР, ПРО_ЗАДАН, и нет никаких других детерминантов. Следовательно, отношение ПРОЕКТЫ находится в BCNF. 

Но при этом оно обладает недостатками: если, например, некоторый сотрудник присоединяется к данному проекту, 
необходимо вставить в отношение ПРОЕКТЫ столько кортежей, сколько заданий в нем предусмотрено. 

#### Многозначные зависимости 

В отношении R (A, B, C) существует многозначная зависимость R.A -> -> R.B в том и только в том случае, 
если множество значений B, соответствующее паре значений A и C, зависит только от A и не зависит от С. 

В отношении ПРОЕКТЫ существуют следующие две многозначные зависимости: 

ПРО_НОМЕР -> -> ПРО_СОТР 
ПРО_НОМЕР -> -> ПРО_ЗАДАН 

Легко показать, что в общем случае в отношении R (A, B, C) существует 
многозначная зависимость R.A -> -> R.B в том и только в том случае, когда существует многозначная зависимость R.A -> -> R.C. 

Дальнейшая нормализация отношений, подобных отношению ПРОЕКТЫ, основывается на следующей теореме: 

#### Теорема Фейджина 

Отношение R (A, B, C) можно спроецировать без потерь в отношения R1 (A, B) и R2 (A, C) в том и только в том случае, 
когда существует MVD A -> -> B | C. 
Под проецированием без потерь понимается такой способ декомпозиции отношения, 
при котором исходное отношение полностью и без избыточности восстанавливается путем естественного соединения полученных отношений. 

### Четвертая нормальная форма 

Отношение R находится в четвертой нормальной форме (4NF) в том и только в том случае, 
если в случае существования многозначной зависимости A -> -> B все остальные атрибуты R функционально зависят от A. 

В нашем примере можно произвести декомпозицию отношения ПРОЕКТЫ в два отношения ПРОЕКТЫ-СОТРУДНИКИ и ПРОЕКТЫ-ЗАДАНИЯ: 

ПРОЕКТЫ-СОТРУДНИКИ (ПРО_НОМЕР, ПРО_СОТР) 
ПРОЕКТЫ-ЗАДАНИЯ (ПРО_НОМЕР, ПРО_ЗАДАН) 

Оба эти отношения находятся в 4NF и свободны от отмеченных аномалий. 

### Пятая нормальная форма

Во всех рассмотренных до этого момента нормализациях производилась декомпозиция одного отношения в два. 
Иногда это сделать не удается, но возможна декомпозиция в большее число отношений, каждое из которых обладает лучшими свойствами. 

Рассмотрим, например, отношение 

СОТРУДНИКИ-ОТДЕЛЫ-ПРОЕКТЫ (СОТР_НОМЕР, ОТД_НОМЕР, ПРО_НОМЕР) 

Предположим, что один и тот же сотрудник может работать в нескольких отделах 
и работать в каждом отделе над несколькими проектами. 
Первичным ключем этого отношения является полная совокупность его атрибутов, отсутствуют функциональные и многозначные зависимости. 

Поэтому отношение находится в 4NF. 

Однако в нем могут существовать аномалии, которые можно устранить путем декомпозиции в три отношения. 

#### Зависимость соединения 

Отношение R (X, Y, ..., Z) удовлетворяет зависимости соединения * (X, Y, ..., Z) 
в том и только в том случае, когда R восстанавливается без потерь путем соединения своих проекций на X, Y, ..., Z. 

#### Пятая нормальная форма 

Отношение R находится в пятой нормальной форме (нормальной форме проекции-соединения - PJ/NF) 
в том и только в том случае, когда любая зависимость соединения в R следует из существования некоторого возможного ключа в R. 

Введем следующие имена составных атрибутов: 

СО = {СОТР_НОМЕР, ОТД_НОМЕР} 
СП = {СОТР_НОМЕР, ПРО_НОМЕР} 
ОП = {ОТД_НОМЕР, ПРО_НОМЕР} 

Предположим, что в отношении СОТРУДНИКИ-ОТДЕЛЫ-ПРОЕКТЫ существует зависимость соединения: 

* (СО, СП, ОП) 

На примерах легко показать, что при вставках и удалениях кортежей могут возникнуть проблемы. 
Их можно устранить путем декомпозиции исходного отношения в три новых отношения: 

СОТРУДНИКИ-ОТДЕЛЫ (СОТР_НОМЕР, ОТД_НОМЕР) 
СОТРУДНИКИ-ПРОЕКТЫ (СОТР_НОМЕР, ПРО_НОМЕР) 
ОТДЕЛЫ-ПРОЕКТЫ (ОТД_НОМЕР, ПРО_НОМЕР) 

Пятая нормальная форма - это последняя нормальная форма, которую можно получить путем декомпозиции. 
Ее условия достаточно нетривиальны, и на практике 5NF не используется. 
Заметим, что зависимость соединения является обобщением как многозначной зависимости, так и функциональной зависимости. 

### Денормализация

Денормализация — это умышленное изменение структуры базы, нарушающее правила нормальных форм. 
Обычно это делается с целью улучшения производительности базы данных.

Теоретически, надо всегда стремиться к полностью нормализованной базе, 
однако на практике полная нормализация базы почти всегда означает падение производительности. 
Чрезмерная нормализация базы данных может привести к тому, что при каждом извлечении данных придется 
обращаться к нескольким таблицам. Обычно в запросе должны участвовать четыре таблицы или менее.
Стандартными приемами денормализации являются: объединение нескольких таблиц в одну, 
сохранение одинаковых атрибутов в нескольких таблицах, а также хранение в таблице сводных или вычисляемых данных.



### Связь один к одному

Каждой записи первой сущности соответствует только одна запись из второй сущности. 
А каждой записи второй сущности соответствует только одна запись из первой сущности. 
Например, есть две сущности: Люди и Свидетельства о рождении. 
И у одного человека может быть только одно свидетельство о рождении.

```sql
CREATE TABLE A1
(
 id1 int PRIMARY KEY,
 value1 nvarchar(50) NOT NULL
)
GO

CREATE TABLE A2
(
 id2 int PRIMARY KEY,
 value2 nvarchar(50) NOT NULL
)
GO

ALTER TABLE A2
 ADD FOREIGN KEY (id2) REFERENCES A1(id1)
 ON DELETE CASCADE
GO
```
Важно понимать что мы не сможем создать запись в таблице А2, если такого значения id2 нет в таблице А1 в поле id1.
Но можем создать запись в таблице А1, если такого значения id1 нет в таблице А2 в поле id2.
То есть таблица А1 является первичной в связи.


### Связь один ко многим

Каждой записи первой сущности могут соответствовать несколько записей из второй сущности. 
Однако каждой записи второй сущности соответствует только одна запись из первой сущности. 
Например, есть две сущности: Заказ и Позиция заказа. И в одном заказе может быть много товаров.

Или: клиенты и счета имеют связь (состоят в отношениях) один-ко-многим потому, 
что один клиент может открыть много счетов, но каждый конкретный счёт (или их множество) оформлен только одним клиентом, 
т.е. может иметь только одного клиента.

В этом примере важным является – то, что для связи один-ко-многим необходимо две отдельные таблицы. 
Одна для клиентов, другая для банклвских счетов.

Эти две таблицы (клиентов и счетов) связаны потому, что поле CUST_ID в таблице счетов ссылается 
на первичный ключ (CUST_ID) таблицы клиентов. Такая связь называется связью по внешнему ключу. 
Вы должны представлять себе внешний ключ как простую копию (копию значения) первичного ключа другой таблицы. 
В нашем случае значение поля CUST_ID из таблицы клиентов копируется в таблицу счетов при вставке каждой записи. 
Таким образом, у нас каждый счёт привязан к клиенту. И счетов у каждого клиента может быть много, как и говорилось выше.

Внешние ключи применяются для установки связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, 
подчиненной таблицы, и указывает на один из столбцов из главной таблицы. 
Хотя, как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы, 
но это необязательно должно быть непременным условием. 
Внешний ключ также может указывать на какой-то другой столбец, который имеет [уникальное значение](https://metanit.com/sql/sqlserver/3.5.php).

### Связь многие ко многим

Если связь многие к многим, то в кросс-таблице первичный ключ должен быть составным и включать в себя оба поля. 
Еще неплохо бы сделать их FOREGN KEY.
То есть сначала создаются основные таблицы.
Потом создается таблица связки (через ALTER TABLE указываем, что поля вообще то связаны по внешним ключам)

Для реализации связи многие ко многим лучше использовать некий посредник между двумя рассматриваемыми таблицами. 
Он должен хранить два внешних ключа, первый из которых ссылается на первую таблицу, а второй — на вторую.
