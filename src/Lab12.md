---
title: Лабораторная работа 12
---

### [Нормализация](https://habr.com/ru/post/254773/)


Нормальная форма — требование, предъявляемое к структуре таблиц в теории реляционных баз данных 
для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).

Метод нормальных форм (НФ) состоит в сборе информации о объектах решения задачи в рамках одного отношения 
и последующей декомпозиции этого отношения на несколько взаимосвязанных отношений на основе процедур нормализации отношений.

Цель нормализации: исключить избыточное дублирование данных, которое является причиной аномалий, 
возникших при добавлении, редактировании и удалении кортежей(строк таблицы).

Аномалией называется такая ситуация в таблице БД, которая приводит к противоречию в БД 
либо существенно усложняет обработку БД. Причиной является излишнее дублирование данных в таблице, 
которое вызывается наличием функциональных зависимостей от не ключевых атрибутов.

Аномалии-модификации проявляются в том, что изменение одних данных может повлечь просмотр всей таблицы 
и соответствующее изменение некоторых записей таблицы.

Аномалии-удаления — при удалении какого либо кортежа из таблицы может пропасть информация, 
которая не связана на прямую с удаляемой записью.

Аномалии-добавления возникают, когда информацию в таблицу нельзя поместить, пока она не полная, 
либо вставка записи требует дополнительного просмотра таблицы.

### Первая нормальная форма

Отношение находится в 1НФ, если все его атрибуты являются простыми, 
все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице.

Например, есть таблица «Автомобили»:


<img src="[drawing.jpg](https://user-images.githubusercontent.com/144112831/b822043e-ca27-4a20-875d-10beff833314.png)" alt="drawing" width="300"/>

Нарушение нормализации 1НФ происходит в моделях BMW, т.к. в одной ячейке содержится список из 3 элементов: M5, X5M, M1, 
т.е. он не является атомарным. Преобразуем таблицу к 1НФ:

<img src="[drawing.jpg](https://user-images.githubusercontent.com/144112831/276111739-0c6e7e5d-122a-49e6-bcc6-ab8cad68a50e.png)" alt="drawing" width="300"/>

### Вторая нормальная форма

Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от Первичного Ключа(ПК).

Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, 
от которого можно также вывести данную функциональную зависимость.

Например, дана таблица:
![Screenshot from 2023-10-18 12-55-18](https://github.com/goryachkinama/db-practice/assets/144112831/c3f3d7e6-ca2f-4645-9477-26b6344218fd)
// pic.3

Таблица находится в первой нормальной форме, но не во второй. Цена машины зависит от модели и фирмы. 
Скидка зависят от фирмы, то есть зависимость от первичного ключа неполная. 
Исправляется это путем декомпозиции на два отношения, в которых не ключевые атрибуты зависят от ПК.
![Screenshot from 2023-10-18 12-56-12](https://github.com/goryachkinama/db-practice/assets/144112831/3eb0b101-015e-40b8-a79e-e9ff939fc2de)
// pic.4
![Screenshot from 2023-10-18 12-56-18](https://github.com/goryachkinama/db-practice/assets/144112831/144eec68-20d6-4f66-ac1b-40440d1ed7c4)
// pic.5

### Третья нормальная форма

Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа. 
Проще говоря, второе правило требует выносить все не ключевые поля, 
содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы.

Рассмотрим таблицу:
![Screenshot from 2023-10-18 12-56-55](https://github.com/goryachkinama/db-practice/assets/144112831/74d65e48-b77b-4d61-a1c8-e503631ba008)
// pic.6

Таблица находится во 2НФ, но не в 3НФ.
В отношении атрибут «Модель» является первичным ключом. Личных телефонов у автомобилей нет, 
и телефон зависит исключительно от магазина.

Таким образом, в отношении существуют следующие функциональные зависимости: 
Модель → Магазин, Магазин → Телефон, Модель → Телефон.

Зависимость Модель → Телефон является транзитивной, следовательно, отношение не находится в 3НФ.
В результате разделения исходного отношения получаются два отношения, находящиеся в 3НФ:
![Screenshot from 2023-10-18 12-57-42](https://github.com/goryachkinama/db-practice/assets/144112831/2b55c60c-62bc-4021-9c5a-701837afcc38)
// pic.7
![Screenshot from 2023-10-18 12-57-49](https://github.com/goryachkinama/db-practice/assets/144112831/4d6e48f1-748a-40fb-b09b-822a99990cf1)
// pic.8

### Денормализация

Денормализация — это умышленное изменение структуры базы, нарушающее правила нормальных форм. 
Обычно это делается с целью улучшения производительности базы данных.

Теоретически, надо всегда стремиться к полностью нормализованной базе, 
однако на практике полная нормализация базы почти всегда означает падение производительности. 
Чрезмерная нормализация базы данных может привести к тому, что при каждом извлечении данных придется 
обращаться к нескольким таблицам. Обычно в запросе должны участвовать четыре таблицы или менее.
Стандартными приемами денормализации являются: объединение нескольких таблиц в одну, 
сохранение одинаковых атрибутов в нескольких таблицах, а также хранение в таблице сводных или вычисляемых данных.



### Связь один к одному

Каждой записи первой сущности соответствует только одна запись из второй сущности. 
А каждой записи второй сущности соответствует только одна запись из первой сущности. 
Например, есть две сущности: Люди и Свидетельства о рождении. 
И у одного человека может быть только одно свидетельство о рождении.

```sql
CREATE TABLE A1
(
 id1 int PRIMARY KEY,
 value1 nvarchar(50) NOT NULL
)
GO

CREATE TABLE A2
(
 id2 int PRIMARY KEY,
 value2 nvarchar(50) NOT NULL
)
GO

ALTER TABLE A2
 ADD FOREIGN KEY (id2) REFERENCES A1(id1)
 ON DELETE CASCADE
GO
```
Важно понимать что мы не сможем создать запись в таблице А2, если такого значения id2 нет в таблице А1 в поле id1.
Но можем создать запись в таблице А1, если такого значения id1 нет в таблице А2 в поле id2.
То есть таблица А1 является первичной в связи.


### Связь один ко многим

Каждой записи первой сущности могут соответствовать несколько записей из второй сущности. 
Однако каждой записи второй сущности соответствует только одна запись из первой сущности. 
Например, есть две сущности: Заказ и Позиция заказа. И в одном заказе может быть много товаров.

Или: клиенты и счета имеют связь (состоят в отношениях) один-ко-многим потому, 
что один клиент может открыть много счетов, но каждый конкретный счёт (или их множество) оформлен только одним клиентом, 
т.е. может иметь только одного клиента.

В этом примере важным является – то, что для связи один-ко-многим необходимо две отдельные таблицы. 
Одна для клиентов, другая для банклвских счетов.

Эти две таблицы (клиентов и счетов) связаны потому, что поле CUST_ID в таблице счетов ссылается 
на первичный ключ (CUST_ID) таблицы клиентов. Такая связь называется связью по внешнему ключу. 
Вы должны представлять себе внешний ключ как простую копию (копию значения) первичного ключа другой таблицы. 
В нашем случае значение поля CUST_ID из таблицы клиентов копируется в таблицу счетов при вставке каждой записи. 
Таким образом, у нас каждый счёт привязан к клиенту. И счетов у каждого клиента может быть много, как и говорилось выше.

Внешние ключи применяются для установки связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, 
подчиненной таблицы, и указывает на один из столбцов из главной таблицы. 
Хотя, как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы, 
но это необязательно должно быть непременным условием. 
Внешний ключ также может указывать на какой-то другой столбец, который имеет [уникальное значение](https://metanit.com/sql/sqlserver/3.5.php).

### Связь многие ко многим

Если связь многие к многим, то в кросс-таблице первичный ключ должен быть составным и включать в себя оба поля. 
Еще неплохо бы сделать их FOREGN KEY.
То есть сначала создаются основные таблицы.
Потом создается таблица связки (через ALTER TABLE указываем, что поля вообще то связаны по внешним ключам)

Для реализации связи многие ко многим лучше использовать некий посредник между двумя рассматриваемыми таблицами. 
Он должен хранить два внешних ключа, первый из которых ссылается на первую таблицу, а второй — на вторую.
