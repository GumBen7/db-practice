---
title: Лабораторная работа 7. Переменные и управляющие конструкции
---

[Таблица стран](assets/lab3/Страны.xlsx)

[Таблица учеников](assets/lab5/Students.xlsx)

[К списку лабораторных >>>](../README.md)

---

### Задание по таблице учеников

1. Даны числа A и B. Найти и вывести их произведение.
2. В таблице «Ученики» найти разницу между средними баллами лицеистов и гимна-
зистов.
3. В таблице «Ученики» проверить на четность количество строк.
4. Дано четырехзначное число. Вывести сумму его цифр.
5. Даны случайные целые числа a, b и c. Найти наименьшее из них.
6. Дано случайное целое число a. Проверить, делится ли данное число на 11.
7. Дано случайное целое число N (N < 1000). Если оно является степенью числа 3, то
вывести «Да», если не является – вывести «Нет».
8. Даны случайные целые числа a и b. Найти наименьший общий кратный (НОК).
9. Даны два целых числа A и B (A<B). Найти сумму квадратов всех целых чисел от A
до B включительно.
10. Найти первое натуральное число, которое при делении на 2, 3, 4, 5, и 6 дает остаток
1, но делится на 7.
11. Вывести свою фамилию на экран столько раз, сколько в нем букв.
12. Напишите код для вывода на экран с помощью цикла:
Н
иНи
жиНиж
нжиНижн
енжиНижне
венжиНижнев
авенжиНижнева
равенжиНижневар
травенжиНижневарт
отравенжиНижневарто
вотравенжиНижневартов
свотравенжиНижневартовс
ксвотравенжиНижневартовск
---

### Задание по таблице стран

Переписать следующие задания, используя переменные:

---

### Ещё задания. Со звёздочкой *


---

### [Переменные](https://metanit.com/sql/sqlserver/9.1.php)

Несмотря на то, что T-SQL – декларативный язык, у него есть расширение, 
позволяющее обрабатывать ошибки, создавать и выполнять хранимые процедуры и пользовательские функции, 
триггеры и сценарии с использованием локальных переменных, операторов присваивания, ветвлений и циклов.

Объявление переменной осуществляется с помощью оператора DECLARE. 

Упрощенный синтаксис команды имеет следующий вид:
```sql
DECLARE <@название> AS <тип>
```

Имена переменных в Transact-SQL начинаются с символа @.

Объявить сразу несколько переменных одним оператором DECLARE можно так:
```sql
DECLARE <@название1> AS <тип1>, …, <@названиеN> AS <типN>
```

Ключевое слово AS необязательно.

При объявлении переменной можно ее инициализировать:
```sql
DECLARE <@название> AS <тип> = <значение>
```

Объявленным переменным можно присвоить различные значения с помощью оператора присваивания SET. 

Переменным должны присваиваться значения того типа данных, с каким они были объявлены. 

Упрощенный синтаксис команды имеет следующий вид:
```sql
SET <@название> = <значение>
```

Переменным можно присваивать скалярный результат выполнения запросов:
```sql
SET <@название> = (SELECT <значение> FROM <таблица>)
```

Неинициализированные переменные имеют значение NULL, их нельзя использовать в выражениях.

Переменным можно присваивать значения с помощью команды SELECT:
```sql
SELECT <@переменная1> = <столбец1>, …, <@переменнаяN> = <столбецN>
FROM <таблица>
```
  
Значения переменных можно вывести с помощью команды PRINT.
Синтаксис команды имеет следующий вид:
```sql
PRINT <сообщение>
```

Сообщение может быть символьной константой, переменной символьного типа, переменной, 
неявно преобразуемой в последовательность символов, или выражения, возвращающего символьный результат.

Значения переменных можно вывести с помощью команды SELECT.
Синтаксис команды имеет следующий вид:
```sql
SELECT <@переменная1> [AS псевдоним1], …, <@переменнаяN> [AS псевдонимN]
```
---

### Условные выражения

Для выполнения команды в зависимости от условия используется управляющая команда IF ... ELSE … . 
Инструкция, следующая за ключевым словом IF и его условием, выполняется только в том случае, 
если логическое выражение возвращает TRUE. 
Необязательное ключевое слово ELSE представляет другую инструкцию, которая выполняется, 
если условие IF не удовлетворяется и логическое выражение возвращает FALSE. 

Упрощенный синтаксис команды имеет следующий вид:
```sql
IF <условие>
[BEGIN]
<команды>
[END]
[ ELSE
[BEGIN]
<команды>
[END]
]
```

Условие должно возвращать только TRUE (ИСТИНА) или FALSE (ЛОЖЬ).

Если в блоке более чем одна команда, использование [BEGIN] … [END] обязательно.

---

### Циклы

Для выполнения повторяющихся операций применяется цикл WHILE.
Упрощенный синтаксис команды имеет следующий вид:

```sql
WHILE <условие>
[BEGIN]
<команды| BREAK | CONTINUE >
[END]
```

Команда BREAK приводит к выходу из цикла и вызывает инструкции, 
следующие за ключевым словом END, обозначающим конец цикла.

Команда CONTINUE пропускает все команды после себя до конца цикла и переводит
цикл на следующий шаг.

---

### try/catch и Обработка ошибок

Для обработки ошибок в T-SQL применяется конструкция TRY...CATCH. 

Она имеет следующий формальный синтаксис:
```sql
BEGIN TRY
    инструкции
END TRY
BEGIN CATCH
    инструкции
END CATCH
```

Между выражениями BEGIN TRY и END TRY помещаются инструкции, 
которые потенциально могут вызвать ошибку, например, какой-нибудь запрос. 
И если в этом блоке TRY возникнет ошибка, то управление передается в блок CATCH, где можно обработать ошибку.

В блоке CATCH для обаботки ошибки мы можем использовать ряд функций:

* ERROR_NUMBER(): возвращает номер ошибки
* ERROR_MESSAGE(): возвращает сообщение об ошибке
* ERROR_SEVERITY(): возвращает степень серьезности ошибки. 
  Степень серьезности представляет числовое значение.
  И если оно равно 10 и меньше, то такая ошибка рассматривается как предупреждение и не обрабатывается конструкцией TRY...CATCH.
  Если же это значение равно 20 и выше, то такая ошибка приводит к закрытию подключения к базе данных, если она не обрабатывается конструкцией TRY...CATCH.
* ERROR_STATE(): возвращает состояние ошибки

Например, добавим в таблицу данные, которые не соответствуют ограничениям столбцов:
```sql
CREATE TABLE Accounts (FirstName NVARCHAR NOT NULL, Age INT NOT NULL)
 
BEGIN TRY
    INSERT INTO Accounts VALUES(NULL, NULL)
    PRINT 'Данные успешно добавлены!'
END TRY
BEGIN CATCH
    PRINT 'Error ' + CONVERT(VARCHAR, ERROR_NUMBER()) + ':' + ERROR_MESSAGE()
END CATCH
```

В данном случае для столбцов таблицы вставляются недопустимые данные - значения NULL, поэтому обработка программы перейдет к блоку CATCH

---
