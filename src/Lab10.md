---
title: Лабораторная работа 10. Индексы и ограничения
---

[Таблица стран](assets/lab3/Страны.xlsx)

[Таблица учеников](assets/lab5/Students.xlsx)

[К списку лабораторных >>>](../README.md)

---

### Задания по таблицам из демо-экзамена

Через "ALTER TABLE имя_таблицы ADD CONSTRAINT ..." добавить ограничения для столбцов, согласно ТЗ ([вариант 2](assets/lab/v2.md), примерный список):

* Поля: идентификатор, дата добавления, дата посещения - генерируются автоматически и являются неизменяемыми
* Поля фамилии, имени и отчества не могут быть длиннее 50 символов
* Поле телефона может содержать только цифры и следующие символы: плюс, минус, открывающая и закрывающая круглые скобки, знак пробела.
* Размер фотографии не должен превышать 2 мегабайта (т.е. мы работаем с PhotoPath, то ввести ограничение на длину строки с путём к файлу)

Опционально (рекомендую сделать, но в ТЗ этого нет):

* Попробовать задать варианты значений для именования пола в таблице с полами через команду CHECK 
* Уникальность телефона и email, чтобы исключить возможность заводить клиентов с одинаковыми контактными данными
  (такое может не сработать для случая родитель-ребенок, но в большинстве других это имеет смысл)

* Написать скрипты для добавления записей с корректными и некорректными данными.
  Можно реализовать обработку ошибок через try-catch

---

### Задания на индексы по таблицам ???

Реорганизация индекса

Перестроение индекса

Создание индексированных представлений

---

### Ограничения

```sql
ALTER TABLE имя_таблицы ADD перечень_полей_с_характеристиками 
```
– позволяет добавить новые поля в таблицу;

```sql
ALTER TABLE имя_таблицы DROP COLUMN перечень_полей 
```
– позволяет удалить поля из таблицы;

```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения 
FOREIGN KEY(поля) REFERENCES таблица_справочник(поля) 
```
– позволяет определить связь между таблицей и таблицей справочником

Добавление свойства IDENTITY к полю 
– позволяет сделать это поле автоматически заполняемым (полем-счетчиком) для таблицы;

Все виды ограничений, которые создаются командой вида 
```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения
```

PRIMARY KEY – первичный ключ;
FOREIGN KEY – настройка связей и контроль ссылочной целостности данных;
UNIQUE – позволяет создать уникальность;
CHECK – позволяет осуществлять корректность введенных данных;
DEFAULT – позволяет задать значение по умолчанию;

Все ограничения можно удалить, используя команду вида
```sql
ALTER TABLE имя_таблицы DROP CONSTRAINT имя_ограничения
```
---

### Прочие ограничения (UNIQUE, DEFAULT, CHECK)

#### UNIQUE

При помощи ограничения UNIQUE можно сказать, что значения для каждой строки в данном поле или в наборе полей должно быть уникальным.

```sql
CREATE TABLE Production.TransactionHistoryArchive4  
 (  
   TransactionID int NOT NULL,   
   CONSTRAINT AK_TransactionID UNIQUE(TransactionID)   
)

ALTER TABLE Employees ADD CONSTRAINT UQ_Employees_Email UNIQUE(Email)

ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения UNIQUE(поле1,поле2,…)
```

#### DEFAULT

При помощи добавления к полю ограничения DEFAULT мы можем задать значение по умолчанию, 
которое будет подставляться в случае, если при вставке новой записи данное поле не будет перечислено в списке полей команды INSERT.

```sql
ALTER TABLE Employees ADD HireDate date NOT NULL DEFAULT SYSDATETIME()

ALTER TABLE Employees ADD DEFAULT SYSDATETIME() FOR HireDate

ALTER TABLE Employees ADD CONSTRAINT DF_Employees_HireDate DEFAULT SYSDATETIME() FOR HireDate
```

#### CHECK

Проверочное ограничение CHECK используется в том случае, когда необходимо осуществить проверку вставляемых в поле значений. 
Например, наложим данное ограничение на поле табельный номер, которое у нас является идентификатором сотрудника (ID). 
При помощи данного ограничения скажем, что табельные номера должны иметь значение от 1000 до 1999:

```sql
ALTER TABLE Employees ADD CONSTRAINT CK_Employees_ID CHECK(ID BETWEEN 1000 AND 1999)
```

Можно так же создать ограничения UNIQUE и CHECK без указания имени:

```sql
ALTER TABLE Employees ADD UNIQUE(Email) ALTER TABLE Employees 
ADD CHECK(ID BETWEEN 1000 AND 1999)
```

Мы можем также использовать ограничение CHECK чтобы защитить от ввода в поле определенных значений, и таким образом предотвратить ошибку. 
Например, предположим, что единствеными городами в которых мы имели ведомства сбыта являются Лондон, Барселона, Сан Хосе, и Нью Йорк. 
Если вам известны все продавцы, работающие в каждом из этих ведомств, нет необходимости позволять ввод других значений. 
Если же нет, использование ограничения может предотвратить опечатки и другие ошибки.

```sql
CREATE TABLE Salespeople
(snum integer NOT NULL UNIQUE,
sname char(10) NOT NULL UNIQUE,
city char(10)
CHECK (city IN ('London', 'New York', 'San Jose', 'Barselona')),
comm decimal CHECK (comm<1));
```

Вы можете также использовать CHECK в качестве табличного ограничения. 
Это полезно в тех случаях, когда вы хотите включить более одного поля строки в условие.
Предположим, что комиссионные .15 и выше будут разрешены только для продавца из Барселоны. 

Вы можете указать это со следующим табличным ограничением CHECK:
```sql
CREATE TABLE Salespeople
(snum integer NOT NULL UNIQUE,
sname char (10) NOT NULL UNIQUE,
city char(10),
comm decimal,
CHECK (comm < .15 OR city = 'Barcelona'))
```

---

### ON DELETE и ON UPDATE

Напоследок стоит сказать, что ссылочные ключи могут включать дополнительные опции 
ON DELETE CASCADE и ON UPDATE CASCADE, которые говорят о том, как вести себя при удалении или обновлении записи, 
на которую есть ссылки в таблице-справочнике. 

Если эти опции не указаны, то мы не можем изменить ID в таблице справочнике у той записи, 
на которую есть ссылки из другой таблицы, так же мы не сможем удалить такую запись из справочника, 
пока не удалим все строки, ссылающиеся на эту запись или, же обновим в этих строках ссылки на другое значение.

И для определения действия мы можем использовать следующие опции:

* NO ACTION: предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице.
  То есть фактически какие-либо действия отсутствуют.

* CASCADE: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.

* SET NULL: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL.

* SET DEFAULT: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию,
  которое задается с помощью атрибуты DEFAULT. Если для столбца не задано значение по умолчанию,
  то в качестве него применяется значение NULL.

#### CASCADE

Для примера пересоздадим таблицу с указанием опции ON DELETE CASCADE для FK_Employees_DepartmentID:
```sql
DROP TABLE Employees

CREATE TABLE Employees(
  ID int NOT NULL,
  Name nvarchar(30),
  Birthday date,
  Email nvarchar(30),
  PositionID int,
  DepartmentID int,
  ManagerID int,
CONSTRAINT PK_Employees PRIMARY KEY (ID), 
CONSTRAINT FK_Employees_DepartmentID
  FOREIGN KEY(DepartmentID)
  REFERENCES Departments(ID)
  ON DELETE CASCADE, 
CONSTRAINT FK_Employees_PositionID
  FOREIGN KEY(PositionID)
  REFERENCES Positions(ID),
CONSTRAINT FK_Employees_ManagerID
  FOREIGN KEY (ManagerID)
  REFERENCES Employees(ID)
)
INSERT Employees (ID,Name,Birthday,PositionID,DepartmentID,ManagerID)VALUES
(1000,N'Иванов И.И.','19550219',2,1,NULL),
(1001,N'Петров П.П.','19831203',3,3,1003),
(1002,N'Сидоров С.С.','19760607',1,2,1000),
(1003,N'Андреев А.А.','19820417',4,3,1000)
```

Удалим отдел с идентификатором 3 из таблицы Departments:
```sql
DELETE Departments WHERE ID=3
```

Посмотрим на данные таблицы Employees:
```sql
SELECT * FROM Employees
```
Как видим, данные по отделу 3 из таблицы Employees так же удалились.

Опция ON UPDATE CASCADE ведет себя аналогично, но действует она при обновлении значения ID в справочнике (в нашем примере). 
То есть, при изменении значения первичного ключа автоматически изменится значение связанного с ним внешнего ключа. 
Но так как первичные ключи, как правило, изменяются очень редко, 
да и с принципе не рекомендуется использовать в качестве первичных ключей столбцы с изменяемыми значениями, то на практике выражение ON UPDATE используется редко.

Например, если мы поменяем ID должности в справочнике должностей, 
то в этом случае будет производиться обновление DepartmentID в таблице Employees 
на новое значение ID которое мы задали в справочнике. 

Но в данном случае это продемонстрировать просто не получится, 
т.к. у колонки ID в таблице Departments стоит опция IDENTITY, 
которая не позволит нам выполнить следующий запрос (сменить идентификатор отдела 3 на 30):
```sql
UPDATE Departments
SET ID=30
WHERE ID=3
```

Главное понять суть этих 2-х опций ON DELETE CASCADE и ON UPDATE CASCADE,
применять эти опции очень в редких случаях и хорошо подумать, 
прежде чем указывать их в ссылочном ограничении, 
т.к. при нечаянном удалении записи из таблицы справочника это может привести к большим проблемам и создать цепную реакцию.

#### Установка NULL
При установки для внешнего ключа опции SET NULL необходимо, чтобы столбец внешнего ключа допускал значение NULL:

```sql
CREATE TABLE Orders
(
    Id INT PRIMARY KEY IDENTITY,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET NULL
);
```

#### Установка значения по умолчанию

```sql
CREATE TABLE Orders
(
    Id INT PRIMARY KEY IDENTITY,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET DEFAULT
)
```

---


### [Индексы](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/clustered-and-nonclustered-indexes-described?view=sql-server-ver16)

Одним из важнейших путей достижения высокой производительности SQL Server является использование индексов. 
Индекс ускоряет процесс запроса, предоставляя быстрый доступ к строкам данных в таблице, аналогично тому, 
как указатель в книге помогает вам быстро найти необходимую информацию. 

Индексы создаются для столбцов таблиц и представлений. 
Индексы предоставляют путь для быстрого поиска данных на основе значений в этих столбцах. 
Например, если вы создадите индекс по первичному ключу, а затем будете искать строку с данными,
используя значения первичного ключа, то SQL Server сначала найдет значение индекса, 
а затем использует индекс для быстрого нахождения всей строки с данными. 
Без индекса будет выполнен полный просмотр (сканирование) всех строк таблицы, что может оказать значительное влияние на производительность.

Вы можете создать индекс на большинстве столбцов таблицы или представления. 
Исключением, преимущественно, являются столбцы с типами данных для хранения больших объектов (LOB), 
таких как image, text или varchar(max). Вы также можете создать индексы на столбцах, 
предназначенных для хранения данных в формате XML, но эти индексы устроены немного иначе, чем стандартные.

### [Кластерные (CLUSTERED) индексы](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/create-clustered-indexes?view=sql-server-ver16)

По умолчанию индекс для первичного ключа создается как CLUSTERED, а для всех остальных индексов как NONCLUSTERED. 

Стоит сказать, что понятие кластерного индекса есть не во всех СУБД. Таблица может иметь только один кластерный (CLUSTERED) индекс.

CLUSTERED – означает, что записи таблицы будут сортироваться по этому индексу, так же можно сказать, 
что этот индекс имеет непосредственный доступ ко всем данным таблицы. 
Это так сказать главный индекс таблицы. 
Если сказать еще грубее, то это индекс, прикрученный к таблице. 

Кластерный индекс – это очень мощное средство, которое может помочь при оптимизации запросов.

Кластеризованные индексы реализуются следующими методами:

* Ограничениями PRIMARY KEY и UNIQUE - сли кластеризованный индекс в таблице еще не создан,
  а уникальный некластеризованный индекс еще не указан, то при создании ограничения PRIMARY KEY
  в одном или нескольких столбцах автоматически создается уникальный кластеризованный индекс.
  В первичном ключевом столбце недопустимы значения NULL.

* При создании ограничения UNIQUE создается уникальный некластеризованный индекс.
  Он нужен, чтобы принудительно применять ограничение UNIQUE по умолчанию.
  Если кластеризованный индекс в таблице еще не создан, то можно указать уникальный кластеризованный индекс.

Индексу, создаваемому в составе ограничения, автоматически присваивается то же имя, что и имя ограничения.

### Индекс, не зависящий от ограничения

Можно создать кластеризованный индекс в столбце, отличном от первичного ключевого столбца, если задано ограничение некластеризованного первичного ключа.

Индексы могут быть созданы как для одного атрибута (простые индексы), так и для совокупности атрибутов(составные индексы).
К индексам может быть предъявлено требование уникальности, что означает невозможность существования нескольких записей с одинаковыми значениями индекса.

Кластерные индексы – принципиальным отличие кластерного индекса является то, что при его определении
физическое расположение записей таблицы изменяется в соответствии со структурой индекса, 
т.е. записи в таблице упорядочиваются в соответствии со значением индекса. 
При некластерном индексе каждая новая запись добавляется в конец таблицы, 
а при кластерной записи перемещаются таким образом, что новая помещается в то место, 
которое определяется по значению соответствующего ей индекса. 

Кластерные индексы дают существенное увеличение производительности, 
особенно при работе с совокупностью последовательных записей (идущих одна за другой).

Необходимо избегать создания кластерного индекса для часто изменяемых столбцов (атрибутов), 
поскольку сервер должен будет выполнять физическое перемещение записей таблицы, 
чтобы они находились в упорядоченном состоянии, соответствующем кластерному индексу.

! При создании PRIMARY KEY сервер автоматически создает для него кластерный индекс.

### [Некластерные (NONCLUSTERED) индексы](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/create-nonclustered-indexes?view=sql-server-ver16)

Некластерные индексы - наиболее типичный вид индексов. Они не перестраивают физическую структуру таблицы,
а лишь организуют ссылки, определяющие по значению индекса адреса соответствующих записей.
Если в таблице в дополнение к кластерному индексу создан еще и некластерный индекс, 
то указатель в некластерном индексе ссылается не на физическое положение строки, 
а на соответствующий элемент кластерного индекса, описывающего эту строку, 
что позволяет не перестраивать структуру некластерных индексов каждый раз, 
когда кластерный индекс меняет физический порядок строк в таблице.

Некластеризованные индексы реализуются следующим образом:

* Ограничения UNIQUE - при создании ограничения UNIQUE создается уникальный некластеризованный индекс.
  Он нужен, чтобы принудительно применять ограничение UNIQUE по умолчанию.
  Если кластеризованный индекс в таблице еще не создан, то можно указать уникальный кластеризованный индекс.
  Дополнительные сведения см. в статье Ограничения уникальности и проверочные ограничения.

* Индекс, не зависящий от ограничения - по умолчанию некластеризованный индекс создается в том случае,
  если ранее не был задан кластеризованный индекс. Для таблицы может быть создано не более 999 некластеризованных индексов.
  В это число входят любые индексы, созданные ограничениями PRIMARY KEY или UNIQUE, но не входят XML-индексы.

* Некластеризованный индекс в индексированном представлении - некластеризованные индексы в представлении
  могут создаваться только после создания в нем уникального кластеризованного индекса.

SQL Server 2005 поддерживает до 249 некластеризованных индексов и SQL Server 2008 поддерживает до 999.

Если мы хотим сказать, чтобы кластерный индекс использовался не в первичном ключе, 
а для другого индекса, то при создании первичного ключа мы должны указать опцию NONCLUSTERED:
```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения PRIMARY KEY NONCLUSTERED(поле1,поле2,…)
```

Для примера сделаем индекс ограничения PK_Employees некластерным, а индекс ограничения UQ_Employees_Email кластерным. 
 Первым делом удалим данные ограничения:
```sql
ALTER TABLE Employees DROP CONSTRAINT PK_Employees
ALTER TABLE Employees DROP CONSTRAINT UQ_Employees_Email
```

### Добавление кластерных и некластерных индексов.

А теперь создадим их с опциями CLUSTERED и NONCLUSTERED:
```sql
ALTER TABLE Employees ADD CONSTRAINT PK_Employees PRIMARY KEY NONCLUSTERED (ID)
ALTER TABLE Employees ADD CONSTRAINT UQ_Employees_Email UNIQUE CLUSTERED (Email)
```

### Создание самостоятельных индексов.

Под самостоятельностью здесь имеются в виду индексы, которые создаются не для ограничения PRIMARY KEY или UNIQUE.

Индексы по полю или полям можно создавать следующей командой:
```sql
CREATE INDEX IDX_Employees_Name ON Employees(Name)
```

Так же можно указать опции CLUSTERED, NONCLUSTERED, UNIQUE, 
а так же можно указать направление сортировки каждого отдельного поля ASC (по умолчанию) или DESC:

```sql
CREATE UNIQUE NONCLUSTERED INDEX UQ_Employees_EmailDesc ON Employees(Email DESC)
```

При создании некластерного индекса опцию NONCLUSTERED можно отпустить, 
т.к. она подразумевается по умолчанию, здесь она показана просто, 
чтобы указать позицию опции CLUSTERED или NONCLUSTERED в команде.

Простые индексы так же, как и ограничения, можно создать в контексте команды CREATE TABLE.

Создание таблицы со всеми созданными ограничениями и индексами одной командой CREATE TABLE:
```sql
CREATE TABLE Employees(
  ID int NOT NULL,
  Name nvarchar(30),
  Birthday date,
  Email nvarchar(30),
  PositionID int,
  DepartmentID int,
  HireDate date NOT NULL CONSTRAINT DF_Employees_HireDate DEFAULT SYSDATETIME(),
  ManagerID int,
CONSTRAINT PK_Employees PRIMARY KEY (ID), 
CONSTRAINT FK_Employees_DepartmentID FOREIGN KEY(DepartmentID) REFERENCES Departments(ID), 
CONSTRAINT FK_Employees_PositionID FOREIGN KEY(PositionID) REFERENCES Positions(ID), 
CONSTRAINT FK_Employees_ManagerID FOREIGN KEY (ManagerID) REFERENCES Employees(ID), 
CONSTRAINT UQ_Employees_Email UNIQUE(Email), 
CONSTRAINT CK_Employees_ID CHECK(ID BETWEEN 1000 AND 1999), 
INDEX IDX_Employees_Name(Name)
)
```

В итоге:

Индексы могут повысить скорость выборки данных (SELECT), но индексы уменьшают скорость модификации данных таблицы, 
т.к. после каждой модификации системе будет необходимо перестроить все индексы для конкретной таблицы.

---

### [Удаление индексов](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/delete-an-index?view=sql-server-ver16)

Удалить индекс можно следующей командой:
```sql
DROP INDEX IDX_Employees_Name ON Employees
```
---

### [Изменение индекса](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/modify-an-index?view=sql-server-ver16)

Индексы, созданные в результате применения ограничения PRIMARY KEY или UNIQUE, изменить этим способом нельзя. 
Вместо этого необходимо изменить само ограничение.

В следующем примере с помощью инструкции ALTER INDEX задаются несколько параметров для индекса AK_SalesOrderHeader_SalesOrderNumber.
```sql
ALTER INDEX AK_SalesOrderHeader_SalesOrderNumber ON
    Sales.SalesOrderHeader
SET (
    STATISTICS_NORECOMPUTE = ON,
    IGNORE_DUP_KEY = ON,
    ALLOW_PAGE_LOCKS = ON
    )
;
```

Чтобы добавить, удалить или изменить позицию столбца индекса, необходимо удалить и повторно создать индекс.

---

### [Создание индексированных представлений](https://learn.microsoft.com/ru-ru/sql/relational-databases/views/create-indexed-views?view=sql-server-ver16)

В представлении так же можно создавать индексы.

Первым индексом, создаваемым для представления, должен быть уникальный кластеризованный индекс.

После создания уникального кластеризованного индекса могут быть созданы некластеризованные индексы. 
Создание уникального кластеризованного индекса в представлении повышает производительность запросов, 
так как представление хранится в базе данных таким же образом, как таблица с кластеризованным индексом сохраняется. 
Оптимизатор запросов может использовать индексированные представления для ускорения выполнения запросов. 
Представление не должно ссылаться в запросе оптимизатора, чтобы рассмотреть это представление для подстановки.

---

### [Реорганизация и перестроение индексов](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/reorganize-and-rebuild-indexes?view=sql-server-ver16)

Реорганизация индекса требует меньше ресурсов, чем его перестроение. Поэтому следует считать ее предпочтительным методом для обслуживания индекса, 
если нет веских причин использовать перестроение индекса. Реорганизация всегда выполняется с сохранением подключения. 
Это означает, что не создаются долгосрочные блокировки таблиц и запросы или обновления базовой таблицы во время выполнения операции ALTER INDEX ... REORGANIZE могут продолжаться.

При перестроении старый индекс удаляется, и создается новый.
В зависимости от типа индекса и версии ядра СУБД операция перестроения может выполняться в подключенном или автономном режиме. 
Перестроение индекса в автономном режиме обычно занимает меньше времени, чем с сохранением подключения, 
но при этом используются блокировки на уровне объектов на весь период операции перестроения, то есть запросы к таблице или представлению не выполняются.

Перестроение индекса с сохранением подключения не требует блокировок на уровне объектов до окончания операции, 
если есть возможность устанавливать блокировку на короткий период для выполнения перестроения. 
В зависимости от версии ядра СУБД перестроение индекса с сохранением подключения может запускаться как возобновляемая операция. 
Возобновляемое перестроение индекса можно приостановить, сохраняя ход выполнения до текущего момента.
Операцию возобновляемого перестроения можно возобновить после приостановки или другого прерывания. 
Кроме того, ее можно отменить, если завершение перестроения больше не требуется.

#### Реорганизация индекса
В приведенном ниже примере показано, как реорганизовать индекс IX_Employee_OrganizationalLevel_OrganizationalNode 
в таблице HumanResources.Employee базы данных AdventureWorks2022.

```sql
ALTER INDEX IX_Employee_OrganizationalLevel_OrganizationalNode
    ON HumanResources.Employee
    REORGANIZE;
```

Пример, как реорганизовать индекс columnstore IndFactResellerSalesXL_CCI 
в таблице dbo.FactResellerSalesXL_CCI базы данных AdventureWorksDW2022. 
Эта команда заставляет все закрытые и открытые группы строк в columnstore.

```sql
-- This command forces all closed and open row groups into columnstore.
ALTER INDEX IndFactResellerSalesXL_CCI
    ON FactResellerSalesXL_CCI
    REORGANIZE WITH (COMPRESS_ALL_ROW_GROUPS = ON);
```

#### Реорганизация всех индексов в таблице

Пример, как реорганизовать все индексы в таблице HumanResources.Employee базы данных AdventureWorks2022.

```sql
ALTER INDEX ALL ON HumanResources.Employee
   REORGANIZE;
```

#### Перестроение индекса

Пример, как перестроить единственный индекс на таблице Employee базы данных AdventureWorks2022.

```sql
ALTER INDEX PK_Employee_BusinessEntityID ON HumanResources.Employee
REBUILD
;
```

#### Перестроение всех индексов в таблице

Пример, как перестроить все индексы, связанные с таблицей базы данных AdventureWorks2022, 
используя ключевое слово ALL. Указываются три параметра.
```sql
ALTER INDEX ALL ON Production.Product
REBUILD WITH (FILLFACTOR = 80, SORT_IN_TEMPDB = ON,
              STATISTICS_NORECOMPUTE = ON)
;
```

---

