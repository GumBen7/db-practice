---
title: Лабораторная работа 10. Индексы и ограничения
---

[Таблица стран](assets/lab3/Страны.xlsx)

[Таблица учеников](assets/lab5/Students.xlsx)

[К списку лабораторных >>>](../README.md)

---

### Задания не по таблицам

---

### Ограничения

```sql
ALTER TABLE имя_таблицы ADD перечень_полей_с_характеристиками 
```
– позволяет добавить новые поля в таблицу;

```sql
ALTER TABLE имя_таблицы DROP COLUMN перечень_полей 
```
– позволяет удалить поля из таблицы;

```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения 
FOREIGN KEY(поля) REFERENCES таблица_справочник(поля) 
```
– позволяет определить связь между таблицей и таблицей справочником

Добавление свойства IDENTITY к полю 
– позволяет сделать это поле автоматически заполняемым (полем-счетчиком) для таблицы;

---

### Прочие ограничения (UNIQUE, DEFAULT, CHECK)

При помощи ограничения UNIQUE можно сказать, что значения для каждой строки в данном поле или в наборе полей должно быть уникальным.

```sql
CREATE TABLE Production.TransactionHistoryArchive4  
 (  
   TransactionID int NOT NULL,   
   CONSTRAINT AK_TransactionID UNIQUE(TransactionID)   
)

ALTER TABLE Employees ADD CONSTRAINT UQ_Employees_Email UNIQUE(Email)

ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения UNIQUE(поле1,поле2,…)
```

При помощи добавления к полю ограничения DEFAULT мы можем задать значение по умолчанию, 
которое будет подставляться в случае, если при вставке новой записи данное поле не будет перечислено в списке полей команды INSERT.

```sql
ALTER TABLE Employees ADD HireDate date NOT NULL DEFAULT SYSDATETIME()

ALTER TABLE Employees ADD DEFAULT SYSDATETIME() FOR HireDate

ALTER TABLE Employees ADD CONSTRAINT DF_Employees_HireDate DEFAULT SYSDATETIME() FOR HireDate
```

Проверочное ограничение CHECK используется в том случае, когда необходимо осуществить проверку вставляемых в поле значений. 
Например, наложим данное ограничение на поле табельный номер, которое у нас является идентификатором сотрудника (ID). 
При помощи данного ограничения скажем, что табельные номера должны иметь значение от 1000 до 1999:

```sql
ALTER TABLE Employees ADD CONSTRAINT CK_Employees_ID CHECK(ID BETWEEN 1000 AND 1999)
```

Можно так же создать ограничения UNIQUE и CHECK без указания имени:

```sql
ALTER TABLE Employees ADD UNIQUE(Email) ALTER TABLE Employees 
ADD CHECK(ID BETWEEN 1000 AND 1999)
```

Все виды ограничений, которые создаются командой вида 
```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения
```

PRIMARY KEY – первичный ключ;
FOREIGN KEY – настройка связей и контроль ссылочной целостности данных;
UNIQUE – позволяет создать уникальность;
CHECK – позволяет осуществлять корректность введенных данных;
DEFAULT – позволяет задать значение по умолчанию;

Все ограничения можно удалить, используя команду вида
```sql
ALTER TABLE имя_таблицы DROP CONSTRAINT имя_ограничения
```
---

### Индексы. Кластерный (CLUSTERED) и некластерный (NONCLUSTERED) индекс.

Одним из важнейших путей достижения высокой производительности SQL Server является использование индексов. 
Индекс ускоряет процесс запроса, предоставляя быстрый доступ к строкам данных в таблице, аналогично тому, 
как указатель в книге помогает вам быстро найти необходимую информацию. 

Индексы создаются для столбцов таблиц и представлений. 
Индексы предоставляют путь для быстрого поиска данных на основе значений в этих столбцах. 
Например, если вы создадите индекс по первичному ключу, а затем будете искать строку с данными,
используя значения первичного ключа, то SQL Server сначала найдет значение индекса, 
а затем использует индекс для быстрого нахождения всей строки с данными. 
Без индекса будет выполнен полный просмотр (сканирование) всех строк таблицы, что может оказать значительное влияние на производительность.

Вы можете создать индекс на большинстве столбцов таблицы или представления. 
Исключением, преимущественно, являются столбцы с типами данных для хранения больших объектов (LOB), 
таких как image, text или varchar(max). Вы также можете создать индексы на столбцах, 
предназначенных для хранения данных в формате XML, но эти индексы устроены немного иначе, чем стандартные.

По умолчанию индекс для первичного ключа создается как CLUSTERED, а для всех остальных индексов как NONCLUSTERED. 

Стоит сказать, что понятие кластерного индекса есть не во всех СУБД. Таблица может иметь только один кластерный (CLUSTERED) индекс.

CLUSTERED – означает, что записи таблицы будут сортироваться по этому индексу, так же можно сказать, 
что этот индекс имеет непосредственный доступ ко всем данным таблицы. 
Это так сказать главный индекс таблицы. 

Если сказать еще грубее, то это индекс, прикрученный к таблице. 

Кластерный индекс – это очень мощное средство, которое может помочь при оптимизации запросов.

Индексы могут быть созданы как для одного атрибута (простые индексы), так и для совокупности атрибутов(составные индексы).
К индексам может быть предъявлено требование уникальности, что означает невозможность существования нескольких записей с одинаковыми значениями индекса.

Кластерные индексы – принципиальным отличие кластерного индекса является то, что при его определении
физическое расположение записей таблицы изменяется в соответствии со структурой индекса, 
т.е. записи в таблице упорядочиваются в соответствии со значением индекса. 
При некластерном индексе каждая новая запись добавляется в конец таблицы, 
а при кластерной записи перемещаются таким образом, что новая помещается в то место, 
которое определяется по значению соответствующего ей индекса. 

Кластерные индексы дают существенное увеличение производительности, 
особенно при работе с совокупностью последовательных записей (идущих одна за другой).

Необходимо избегать создания кластерного индекса для часто изменяемых столбцов (атрибутов), 
поскольку сервер должен будет выполнять физическое перемещение записей таблицы, 
чтобы они находились в упорядоченном состоянии, соответствующем кластерному индексу.

При создании Primary Key сервер автоматически создает для него кластерный индекс.

Некластерные индексы - наиболее типичный вид индексов. Они не перестраивают физическую структуру таблицы,
а лишь организуют ссылки, определяющие по значению индекса адреса соответствующих записей.
Если в таблице в дополнение к кластерному индексу создан еще и некластерный индекс, 
то указатель в некластерном индексе ссылается не на физическое положение строки, 
а на соответствующий элемент кластерного индекса, описывающего эту строку, 
что позволяет не перестраивать структуру некластерных индексов каждый раз, 
когда кластерный индекс меняет физический порядок строк в таблице.

SQL Server 2005 поддерживает до 249 некластеризованных индексов и SQL Server 2008 поддерживает до 999.

Если мы хотим сказать, чтобы кластерный индекс использовался не в первичном ключе, 
а для другого индекса, то при создании первичного ключа мы должны указать опцию NONCLUSTERED:
```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения PRIMARY KEY NONCLUSTERED(поле1,поле2,…)
```

Для примера сделаем индекс ограничения PK_Employees некластерным, а индекс ограничения UQ_Employees_Email кластерным. 
 Первым делом удалим данные ограничения:
```sql
ALTER TABLE Employees DROP CONSTRAINT PK_Employees
ALTER TABLE Employees DROP CONSTRAINT UQ_Employees_Email
```

Добавление кластерных и некластерных индексов.
А теперь создадим их с опциями CLUSTERED и NONCLUSTERED:
```sql
ALTER TABLE Employees ADD CONSTRAINT PK_Employees PRIMARY KEY NONCLUSTERED (ID)
ALTER TABLE Employees ADD CONSTRAINT UQ_Employees_Email UNIQUE CLUSTERED (Email)
```

Создание самостоятельных индексов.

Под самостоятельностью здесь имеются в виду индексы, которые создаются не для ограничения PRIMARY KEY или UNIQUE.

Индексы по полю или полям можно создавать следующей командой:
```sql
CREATE INDEX IDX_Employees_Name ON Employees(Name)
```

Так же можно указать опции CLUSTERED, NONCLUSTERED, UNIQUE, 
а так же можно указать направление сортировки каждого отдельного поля ASC (по умолчанию) или DESC:

```sql
CREATE UNIQUE NONCLUSTERED INDEX UQ_Employees_EmailDesc ON Employees(Email DESC)
```

При создании некластерного индекса опцию NONCLUSTERED можно отпустить, 
т.к. она подразумевается по умолчанию, здесь она показана просто, 
чтобы указать позицию опции CLUSTERED или NONCLUSTERED в команде.

Удалить индекс можно следующей командой:
```sql
DROP INDEX IDX_Employees_Name ON Employees
```

Простые индексы так же, как и ограничения, можно создать в контексте команды CREATE TABLE.

Создание таблицы со всеми созданными ограничениями и индексами одной командой CREATE TABLE:
```sql
CREATE TABLE Employees(
  ID int NOT NULL,
  Name nvarchar(30),
  Birthday date,
  Email nvarchar(30),
  PositionID int,
  DepartmentID int,
  HireDate date NOT NULL CONSTRAINT DF_Employees_HireDate DEFAULT SYSDATETIME(),
  ManagerID int,
CONSTRAINT PK_Employees PRIMARY KEY (ID), 
CONSTRAINT FK_Employees_DepartmentID FOREIGN KEY(DepartmentID) REFERENCES Departments(ID), 
CONSTRAINT FK_Employees_PositionID FOREIGN KEY(PositionID) REFERENCES Positions(ID), 
CONSTRAINT FK_Employees_ManagerID FOREIGN KEY (ManagerID) REFERENCES Employees(ID), 
CONSTRAINT UQ_Employees_Email UNIQUE(Email), 
CONSTRAINT CK_Employees_ID CHECK(ID BETWEEN 1000 AND 1999), 
INDEX IDX_Employees_Name(Name)
)
```

В итоге:

Индексы могут повысить скорость выборки данных (SELECT), но индексы уменьшают скорость модификации данных таблицы, 
т.к. после каждой модификации системе будет необходимо перестроить все индексы для конкретной таблицы.

---

### ON DELETE и ON UPDATE

Напоследок стоит сказать, что ссылочные ключи могут включать дополнительные опции 
ON DELETE CASCADE и ON UPDATE CASCADE, которые говорят о том, как вести себя при удалении или обновлении записи, 
на которую есть ссылки в таблице-справочнике. 

Если эти опции не указаны, то мы не можем изменить ID в таблице справочнике у той записи, 
на которую есть ссылки из другой таблицы, так же мы не сможем удалить такую запись из справочника, 
пока не удалим все строки, ссылающиеся на эту запись или, же обновим в этих строках ссылки на другое значение.

И для определения действия мы можем использовать следующие опции:

* NO ACTION: предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице.
  То есть фактически какие-либо действия отсутствуют.

* CASCADE: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.

* SET NULL: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL.

* SET DEFAULT: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию,
  которое задается с помощью атрибуты DEFAULT. Если для столбца не задано значение по умолчанию,
  то в качестве него применяется значение NULL.

#### CASCADE

Для примера пересоздадим таблицу с указанием опции ON DELETE CASCADE для FK_Employees_DepartmentID:
```sql
DROP TABLE Employees

CREATE TABLE Employees(
  ID int NOT NULL,
  Name nvarchar(30),
  Birthday date,
  Email nvarchar(30),
  PositionID int,
  DepartmentID int,
  ManagerID int,
CONSTRAINT PK_Employees PRIMARY KEY (ID), 
CONSTRAINT FK_Employees_DepartmentID
  FOREIGN KEY(DepartmentID)
  REFERENCES Departments(ID)
  ON DELETE CASCADE, 
CONSTRAINT FK_Employees_PositionID
  FOREIGN KEY(PositionID)
  REFERENCES Positions(ID),
CONSTRAINT FK_Employees_ManagerID
  FOREIGN KEY (ManagerID)
  REFERENCES Employees(ID)
)
INSERT Employees (ID,Name,Birthday,PositionID,DepartmentID,ManagerID)VALUES
(1000,N'Иванов И.И.','19550219',2,1,NULL),
(1001,N'Петров П.П.','19831203',3,3,1003),
(1002,N'Сидоров С.С.','19760607',1,2,1000),
(1003,N'Андреев А.А.','19820417',4,3,1000)
```

Удалим отдел с идентификатором 3 из таблицы Departments:
```sql
DELETE Departments WHERE ID=3
```

Посмотрим на данные таблицы Employees:
```sql
SELECT * FROM Employees
```
Как видим, данные по отделу 3 из таблицы Employees так же удалились.

Опция ON UPDATE CASCADE ведет себя аналогично, но действует она при обновлении значения ID в справочнике (в нашем примере). 
То есть, при изменении значения первичного ключа автоматически изменится значение связанного с ним внешнего ключа. 
Но так как первичные ключи, как правило, изменяются очень редко, 
да и с принципе не рекомендуется использовать в качестве первичных ключей столбцы с изменяемыми значениями, то на практике выражение ON UPDATE используется редко.

Например, если мы поменяем ID должности в справочнике должностей, 
то в этом случае будет производиться обновление DepartmentID в таблице Employees 
на новое значение ID которое мы задали в справочнике. 

Но в данном случае это продемонстрировать просто не получится, 
т.к. у колонки ID в таблице Departments стоит опция IDENTITY, 
которая не позволит нам выполнить следующий запрос (сменить идентификатор отдела 3 на 30):
```sql
UPDATE Departments
SET ID=30
WHERE ID=3
```

Главное понять суть этих 2-х опций ON DELETE CASCADE и ON UPDATE CASCADE,
применять эти опции очень в редких случаях и хорошо подумать, 
прежде чем указывать их в ссылочном ограничении, 
т.к. при нечаянном удалении записи из таблицы справочника это может привести к большим проблемам и создать цепную реакцию.

#### Установка NULL
При установки для внешнего ключа опции SET NULL необходимо, чтобы столбец внешнего ключа допускал значение NULL:


CREATE TABLE Orders
(
    Id INT PRIMARY KEY IDENTITY,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET NULL
);

#### Установка значения по умолчанию

CREATE TABLE Orders
(
    Id INT PRIMARY KEY IDENTITY,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET DEFAULT
)

---
