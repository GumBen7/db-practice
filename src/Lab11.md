---
title: Лабораторная работа 11. Курсоры. Оконные функции
---

[Вариант 2](assets/lab/v2.md)

[Таблица академиков](assets/lab2/Академики.xlsx)

[К списку лабораторных >>>](../README.md)

---

### Задания по таблице учеников (оконные функции)

1. Вывести список учеников и разницу между баллами ученика и максимальным баллом в каждой строке.
2. Вывести список учеников и процентное соотношение к среднему баллу в каждой строке.
3. Вывести список учеников и минимальный балл в школе в каждой строке.
4. Вывести список учеников и суммарный балл в школе в каждой строке, отсортировать по школам в оконной функции.
5. Вывести список учеников и номер строки при сортировке по фамилиям в обратном алфавитном порядке.
6. Вывести список учеников, номер строки внутри школы и количество учеников в школе при сортировке по баллам по убыванию.
7. Вывести список учеников и ранг по баллам.
8. Вывести список учеников и сжатый ранг по баллам. Результат отсортировать по фамилии в алфавитном порядке.
9. Вывести список учеников, распределенных по пяти группам по фамилии.
10. Вывести список учеников, распределенных по трем группам по баллам внутри школы.
11. Вывести список учеников и разницу с баллами ученика, находящегося выше на три позиции при сортировке по возрастанию баллов.
12. Вывести список учеников и разницу с баллами следующего ученика при сортировке по убыванию баллов, значение по умолчанию использовать 0.
    
---

### Задания по таблице учеников (курсоры)

1. Создайте курсор, содержащий отсортированные по баллам фамилии и баллы учеников, откройте его, выведите первую строку, закройте и освободите курсор.
2. Создайте курсор с прокруткой, содержащий список учеников, откройте его, выведите пятую, предыдущую, с конца четвертую, следующую, первую строку, закройте и освободите курсор.
3. Создайте курсор с прокруткой, содержащий список учеников, откройте его, выведите последнюю, шесть позиций назад находящуюся, четыре позиций вперед находящуюся строку, закройте и освободите курсор.
4. С помощью курсора, вычислите сумму баллов у учеников с наибольшим и наименьшим баллом.
5. С помощью курсора, сгенерируйте строку вида «Ученики <список фамилий и названий предметов, разделенных запятыми> участвовали в олимпиаде».
6. Создайте курсор, содержащий список учеников, с его помощью выведите учеников с нечетной позицией.
7. Создайте курсор, содержащий отсортированный по убыванию баллов список учеников, откройте его, для каждого ученика выведите фамилию, предмет, школу, баллы и процентное соотношение баллов с предыдущим учеником.

---   

### Оконные функции

Оконные функции используются для вычисления в заданной секции. 
Оконные функции не приводят к группированию строк в одну строку вывода, 
строки сохраняют свои отдельные идентификаторы, а агрегированное значение добавляется к каждой строке.

Для определения секций используется инструкция OVER. 

Упрощенный синтаксис имеет следующий вид:

```sql
<функция> <столбец для вычислений> OVER ([PARTITION BY <столбец для группировки>] [ORDER BY <столбец для сортировки>])
```

Предложение PARTITION BY разделяет результирующий набор запроса на секции. 
Оконная функция применяется к каждой секции отдельно, и вычисление начинается заново для каждой секции.

Предложение ORDER BY определяет сортировку строк в каждой секции результирующего набора.

Оконные функции разделяются на агрегирующие, ранжирующие и функции смещения.

--

### Агрегирующие функции

Агрегирующие функции MAX(), MIN(), SUM, AVG(), COUNT() можно применить к секциям результирующего набора запроса. 

Синтаксис функций имеет следующий вид:

```sql
MAX|MIN|SUM|AVG|COUNT(<столбец>) OVER([PARTITION BY <столбцы>] [ORDER BY <столбцы>])
```

В агрегирующих функциях предложение PARTITION BY можно не указывать, 
тогда функция обрабатывает все строки результирующего набора запроса как одну группу. 
Предложение ORDER BY определяет последовательность, в которой строкам назначаются уникальные номера.
Его также можно не указать.

Пример 5: Вывести список учеников и количество учеников в школе в каждой строке, отсортировать по школам в оконной функции:
```sql
SELECT Фамилия, Предмет, Школа, Баллы
,COUNT(*) OVER(PARTITION BY Школа ORDER BY Школа) AS Кол_Шк
FROM Ученики
```

--

### Ранжирующие функции

Ранжирующие функции возвращают ранжирующее значение для каждой строки в секции и являются недетерминированными.
В ранжирующих функциях предложение PARTITION BY можно не указывать, 
тогда функция обрабатывает все строки результирующего набора запроса как одну группу. 
Предложение ORDER BY определяет последовательность, в которой строкам назначаются уникальные номера. 
Оно должно указываться обязательно.

Transact-SQL содержит следующие ранжирующие функции:

#### ROW_NUMBER

ROW_NUMBER – нумерует выходные данные результирующего набора, то есть, 
возвращает последовательный номер строки, начиная с 1, в секции результирующего набора. 

Синтаксис функции имеет следующий вид:
```sql
ROW_NUMBER( ) OVER([PARTITION BY <столбцы>] ORDER BY <столбцы>)
```

Пример 6: Вывести список учеников и номер строки при сортировке по баллам по убыванию:
```sql
SELECT
ROW_NUMBER() OVER(ORDER BY Баллы DESC) AS Номер_строки
,Фамилия, Предмет, Школа, Баллы
FROM Ученики
```

#### RANK

RANK – возвращает ранг каждой строки в секции результирующего набора. 

Ранг строки вычисляется как единица плюс количество рангов, находящихся до этой строки. 
В отличии от функции ROW_NUMBER, RANK назначает одинаковое значение строкам, претендующим на один ранг. 

Синтаксис функции имеет следующий вид:
```sql
RANK( ) OVER([PARTITION BY <столбцы>] ORDER BY <столбцы>)
```

#### DENSE_RANK

DENSE_RANK – возвращает ранг каждой строки в секции результирующего набора без промежутков в значениях ранжирования. 
Ранг определенной строки равен количеству различных значений рангов, предшествующих строке, увеличенному на единицу. 

Синтаксис функции имеет следующий вид:
```sql
DENSE_RANK( ) OVER([PARTITION BY <столбцы>] ORDER BY <столбцы>)
```

Пример: Вывести список учеников и сжатый ранг по баллам в каждой школе. 
Результат отсортировать по фамилии в алфавитном порядке:
```sql
SELECT
DENSE_RANK() OVER(PARTITION BY Школа ORDER BY Баллы DESC) AS Сж_Ранг_Шк
,Фамилия, Предмет, Школа, Баллы
FROM Ученики
ORDER BY Фамилия
```

#### NTILE

NTILE – распределяет строки упорядоченной секции в заданное количество групп. 
Группы нумеруются, начиная с единицы. Для каждой строки функция NTILE возвращает номер группы, которой принадлежит строка. 

Синтаксис функции имеет следующий вид:
```sql
NTILE(<количество групп>) OVER([PARTITION BY <столбцы>] ORDER BY <столбцы>)
```

Пример: Вывести список учеников, распределенных по двум группам по баллам внутри школы:
```sql
SELECT
NTILE(2) OVER(PARTITION BY Школа ORDER BY Баллы DESC) AS Гр_Балл
,Фамилия, Предмет, Школа, Баллы
FROM Ученики
```

---

### Функции смещения

Функции смещения возвращают значение из другой строки секции результирующего набора запроса. 
Предложение ORDER BY должно указываться обязательно.
Transact-SQL содержит следующие функции смещения:
Функции LAG() и LEAD() – обращаются к данным из предыдущей или последующей строки того же результирующего набора. 

Синтаксис функций имеет следующий вид:
```sql
LAG|LEAD(<столбец> [,<смещение>] [,<значение по умолчанию>]) OVER([PARTI-TION BY <столбцы>] ORDER BY <столбцы>)
```

Пример: Вывести список учеников и разницу с баллами ученика через две позиции при сортировке по убыванию баллов, значение по умолчанию использовать 0:
```sql
SELECT Фамилия, Предмет, Школа, Баллы
,Баллы - LEAD(Баллы, 2, 0) OVER(ORDER BY Баллы DESC) AS Разница
FROM Ученики
```

Параметр «смещение» указывает количество строк до строки перед или после текущей строки, из которой необходимо получить значение.

Если значение аргумента не указано, то по умолчанию принимается 1.
«Значение по умолчанию» должно иметь такой же тип данных, как первый параметр, используется, когда «смещение» находится за пределами секции. 
Если не задано, то возвращается NULL.
Функции FIRST_VALUE() и LAST_VALUE() – возвращают первое или последнее значение из упорядоченного набора значений.

Синтаксис функций имеет следующий вид:
```sql
FIRST_VALUE|LAST_VALUE(<столбец>) OVER([PARTITION BY <столбцы>] OR-DER BY <столбцы>)
```

---

### Примеры



Пример: Вывести список учеников и разницу с баллами последнего ученика в школе при сортировке по убыванию баллов:

```sql
SELECT Фамилия, Предмет, Школа, Баллы
,LAST_VALUE(Баллы) OVER(ORDER BY Баллы RANGE BETWEEN UN-BOUNDED PRECEDING AND UNBOUNDED FOLLOWING) - Баллы AS Разница
FROM
Ученики
```

---

### Курсоры

Инструкции Transact-SQL выполняют операции над множествами, но интерактивным приложениям иногда требуется обрабатывать результаты построчно. 

Для выполнения команд над отдельной строкой предусмотрены курсоры. 
Открытие курсора в результирующем наборе делает возможной его построчную обработку. 
Можно присвоить курсор переменной или параметру с типом данных CURSOR.

Курсоры позволяют усовершенствовать обработку результатов: 

* позиционируясь на отдельные строки результирующего набора;
* получая одну или несколько строк от текущей позиции в результирующем наборе;
* поддерживая изменение данных в строках в текущей позиции результирующего набора;
* поддерживая разные уровни видимости изменений, сделанных другими пользователями для данных, представленных в результирующем наборе;
* предоставляя инструкциям Transact-SQL в скриптах, хранимых процедурах и триггерах доступ к данным результирующего набора.
  
---

### Создание курсоров

Обычно курсоры используются для выбора из базы данных некоторого подмножества хранимой в ней информации. 

В каждый момент времени прикладной программой может быть проверена одна строка курсора. 
Курсоры часто применяются в операторах SQL, встроенных в написанные на языках процедурного типа прикладные программы.
Некоторые из них неявно создаются сервером базы данных, в то время как другие определяются программистами.

В соответствии со стандартом SQL при работе с курсорами можно выделить следующие основные действия: 

* создание или объявление курсора;
* открытие курсора, т.е. наполнение его данными, которые сохраняются в многоуровневой памяти;
* выборка из курсора и изменение с его помощью строк данных;
* закрытие курсора, после чего он становится недоступным для пользовательских программ;
* освобождение курсора, т.е. удаление курсора как объекта, поскольку его закрытие необязательно освобождает ассоциированную с ним память.
  
После освобождения курсора ассоциированная с ним память также освобождается.
При этом становится возможным повторное использование его имени.
В некоторых случаях применение курсора неизбежно. 
Однако по возможности этого следует избегать и работать со стандартными командами обработки данных: 
SELECT, UPDATE, INSERT, DELETE. 
Помимо того, что курсоры не позволяют проводить операции изменения над всем объемом данных, 
скорость выполнения операций обработки данных посредством курсора заметно ниже, чем у стандартных средств Transact-SQL.

SQL Server поддерживает четыре типа курсоров:

* Однонаправленный курсор – указывается как FORWARD_ONLY и не поддерживает прокрутку.
  Он также называется курсором FIREHOSE и поддерживает только получение строк последовательно, от начала до конца курсора.
  Строки нельзя получить из базы данных, пока они не будут выбраны.
  Результаты всех инструкций INSERT, UPDATE и DELETE, влияющих на строки результирующего набора
  (выполненных текущим пользователем или зафиксированных другими пользователями), отображаются как строки, выбранные из курсора.
  
* Статический курсор – полный результирующий набор статического курсора создается в базе данных TEMPDB при открытии курсора.
  Статический курсор всегда отображает результирующий набор точно в том виде, в котором он был при открытии курсора.
  Статическими курсорами обнаруживаются лишь некоторые изменения или не обнаруживаются вовсе,
  но при этом в процессе прокрутки такие курсоры потребляют сравнительно мало ресурсов.
  Статические курсоры всегда доступны только для чтения.

* KEYSET курсор – членство и порядок строк в курсоре, управляемом набором ключей,
  являются фиксированными при открытии курсора.
  Такие курсоры управляются с помощью набора уникальных идентификаторов – ключей.
  Ключи создаются из набора столбцов, который уникально идентифицирует строки результирующего набора.

* Динамический курсор – это противоположность статических курсоров.
  Динамические курсоры отражают все изменения строк в результирующем наборе при прокрутке курсора.
  Значения типа данных, порядок и членство строк в результирующем наборе могут меняться для каждой выборки.
  Все инструкции UPDATE, INSERT и DELETE, выполняемые пользователями, видимы посредством курсора.

Упрощенный шаблон использования курсора имеет следующий синтаксис:

```sql
DECLARE <имя_курсора> CURSOR [FORWARD_ONLY | SCROLL]
FOR <SELECT_оператор>
OPEN <имя_курсора>
FETCH <NEXT|PRIOR|FIRST|LAST|ABSOLUTE <число>| RELATIVE <число>> FROM <имя_курсора> INTO <@переменная>
CLOSE <имя_курсора>
DEALLOCATE <имя_курсора>
```

Инструкция DEALLOCATE удаляет связь между курсором и переменной, и освобождает структуры данных, составляющие курсор.

Пример: Создайте курсор с прокруткой, содержащий список учеников, откройте его, 
выведите пятую, предыдущую, с конца четвертую, шесть позиций назад находящуюся,
четыре позиций вперед находящуюся, следующую, первую, последнюю строку, закройте и освободите курсор:
```sql
DECLARE MyCursor CURSOR SCROLL
FOR
SELECT
ID, Фамилия, Предмет, Школа, Баллы
FROM Ученики
OPEN MyCursor
FETCH ABSOLUTE 5 FROM MyCursor
FETCH PRIOR FROM MyCursor
FETCH ABSOLUTE -4 FROM MyCursor
FETCH RELATIVE -6 FROM MyCursor
FETCH RELATIVE 4 FROM MyCursor
FETCH NEXT FROM MyCursor
FETCH FIRST FROM MyCursor
FETCH LAST FROM MyCursor
CLOSE MyCursor
DEALLOCATE MyCursor
```

---

### Прокрутка и ключевые слова для курсоров

#### OPEN

После создания курсора, чтобы его использовать, надо открыть курсор с помощью команды OPEN. 

#### CLOSE

А команда CLOSE закрывает открытый курсор, высвобождая текущий результирующий набор и снимая блокировки курсоров для строк.
Для получения определенной строки используется команда FETCH.

#### NEXT

Ключевое слово NEXT возвращает следующую строку и перемещает указатель текущей строки на возвращенную строку. 
Если инструкция FETCH NEXT выполняет первую выборку в отношении курсора, она возвращает первую строку в результирующем наборе. 
NEXT является параметром по умолчанию выборки из курсора.

#### PRIOR

Ключевое слово PRIOR возвращает предыдущую строку и перемещает указатель текущей строки на возвращенную строку. 
Если инструкция FETCH PRIOR выполняет первую выборку из курсора, не возвращается никакая строка и положение курсора остается перед первой строкой.

#### FIRST

Ключевое слово FIRST возвращает первую строку в курсоре и делает ее текущей.

#### LAST

Ключевое слово LAST возвращает последнюю строку в курсоре, делая ее текущей.

#### ABSOLUTE

Ключевое слово ABSOLUTE с аргументом – положительным целым числом, 
возвращает строку с указанным номером от начала курсора, и делает ее текущей строкой. 
Если число отрицательное, возвращает строку с указанным номером от конца курсора, делая ее текущей строкой.

#### RELATIVE

Ключевое слово RELATIVE с аргументом – положительным целым числом возвращает строку 
с указанным номером после текущей строки и делает ее текущей строкой. 
Если число отрицательное, возвращает строку с указанным номером до текущей строки и делает ее текущей строкой.
Если число равно 0, возвращает текущую строку.

#### INTO

Ключевое слово INTO позволяет поместить данные из столбцов выборки в локальные переменные. 
Каждая переменная из списка, слева направо, связывается с соответствующим столбцом в результирующем наборе курсора. 
Типы данных переменных должны соответствовать типам данных соответствующего столбца результирующего набора.
Количество переменных и столбцов тоже должны совпадать.

---

### Использование циклов в курсорах

Для обработки результирующего набора построчно можно использовать инструкцию FETCH NEXT в цикле WHILE. 
Как условие в цикле используется функция @@FETCH_STATUS, 
которая возвращает состояние последней инструкции FETCH, вызванной в любом курсоре, открытом в рамках этого подключения.

Функция @@FETCH_STATUS возвращает одно из четырех значений:
0 Инструкция FETCH была выполнена успешно.
-1 Выполнение инструкции FETCH завершилось неудачно или строка оказалась вне пределов результирующего набора.
-2 Выбранная строка отсутствует.
-9 Курсор не выполняет операцию выборки.

Упрощенный синтаксис использования функции @@FETCH_STATUS имеет следующий вид:
  
```sql
FETCH NEXT FROM <имя_курсора>
WHILE @@FETCH_STATUS = 0
BEGIN
FETCH NEXT FROM <имя_курсора>
END
```

Пример: 
С помощью курсора сгенерируйте строку вида «Ученики <список фамилий и названий школ, разделенных запятыми> участвовали в олимпиаде»:

```sql
DECLARE MyCursor CURSOR SCROLL
FOR
SELECT Фамилия, Школа
FROM Ученики
DECLARE @S VARCHAR(2000), @F VARCHAR(50), @W VARCHAR(50)
OPEN MyCursor
SET @S = 'Ученики'
FETCH NEXT FROM MyCursor INTO @F, @W
WHILE @@FETCH_STATUS = 0
BEGIN
SET @S = @S + ', ' + @F + ' из школы "' + @W + '"'
FETCH NEXT FROM MyCursor INTO @F, @W
END
SET @S = @S + ' участвовали на олимпиаде.'
PRINT @S
CLOSE MyCursor
DEALLOCATE MyCursor
```

Пример 5: Создайте курсор, содержащий список учеников, с его помощью выведите учеников с четной позицией:
```sql
DECLARE MyCursor CURSOR SCROLL
FOR
SELECT
ID, Фамилия, Предмет, Школа, Баллы
FROM Ученики
OPEN MyCursor
FETCH ABSOLUTE 2 FROM MyCursor
WHILE @@FETCH_STATUS = 0
BEGIN
FETCH RELATIVE 2 FROM MyCursor
END
CLOSE MyCursor
DEALLOCATE MyCursor
```

---

### Использование переменных в курсорах

Пример: С помощью курсора вычислите среднее арифметическое значение балла у учеников с наибольшим и наименьшим баллом:
```sql
DECLARE MyCursor CURSOR SCROLL
FOR
SELECT Баллы
FROM Ученики
ORDER BY Баллы
DECLARE @S FLOAT = 0, @B FLOAT
OPEN MyCursor
FETCH FIRST FROM MyCursor INTO @B
SET @S = @S + @B
FETCH LAST FROM MyCursor INTO @B
SET @S = @S + @B
SET @S = @S / 2
PRINT @S
CLOSE MyCursor
DEALLOCATE MyCursor
```
