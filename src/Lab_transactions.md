---
title: Лабораторная работа. Транзакции в T-SQL
---

[К списку лабораторных >>>](../README.md)

---

### Задания

1. Создать транзакцию.
2. Произвести ее откат и фиксацию.
3. Показать, что данные:
  * существовали до отката,
  * удалились после отката,
  * снова были добавлены,
  * и затем были успешно зафиксированы.
4. Создать транзакцию в T-SQL с обработкой ошибок. Продемонстрировать случаи успешного и неуспешного завершения транзакций
5. Операторы, неявно завершающие транзакцию

---

### Проблема конкурентного доступа

Данные в базе данных обычно используются совместно 
многими прикладными пользовательскими программами (приложениями). 

Ситуация, когда несколько прикладных пользовательских программ одновременно
выполняют операции чтения и записи одних и тех же данных,
называется одновременным конкурентным (параллельным) доступом (concurrency). 

Таким образом, каждая система управления базами данных должна обладать
каким-либо типом механизма управления для решения проблем,
возникающих вследствие одновременного конкурентного доступа.

В системе баз данных, которая может обслуживать большое число
активных пользовательских приложений таким образом, чтобы эти приложения не мешали друг другу,
возможен высокий уровень одновременного конкурентного доступа.

И наоборот, система баз данных, в которой разные активные приложения мешают друг другу, 
поддерживает низкий уровень одновременного конкурентного доступа.

---

### Модели одновременного конкурентного доступа

Компонент Database Engine поддерживает две разные модели одновременного конкурентного доступа:

* пессимистический одновременный конкурентный доступ;
* оптимистический одновременный конкурентный доступ.

В модели пессимистического одновременного конкурентного доступа для предотвращения 
одновременного доступа к данным, которые используются другим процессом, применяются блокировки. 
Иными словами, система баз данных, использующая модель пессимистического одновременного конкурентного доступа, 
предполагает, что между двумя или большим количеством процессов в любое время может возникнуть конфликт
и поэтому блокирует ресурсы (строку, страницу, таблицу), как только они потребуются в течение периода транзакции. 
Модель пессимистического одновременного конкурентного доступа устанавливает блокировку 
с обеспечением разделяемого доступа, иначе немонопольную блокировку (shared lock) 
на считываемые данные, чтобы никакой другой процесс не мог изменить эти данные. 
Кроме этого, механизм пессимистического одновременного конкурентного доступа 
устанавливает монопольную блокировку (exclusive lock) на изменяемые данные,
чтобы никакой другой процесс не мог их считывать или модифицировать.

Работа оптимистического одновременного конкурентного доступа основана
на предположении маловероятности изменения данных одной транзакцией одновременно с другой.
Компонент Database Engine применяет оптимистический одновременный конкурентный доступ, 
при котором сохраняются старые версии строк, и любой процесс при чтении данных
использует ту версию строки, которая была активной, когда он начал чтение.
Поэтому процесс может модифицировать данные без каких-либо ограничений, 
поскольку все другие процессы, которые считывают эти же данные,
используют свою собственную сохраненную версию. 

Конфликтная ситуация возможна только при попытке двух операций записи 
использовать одни и те же данные. 
В таком случае система выдает ошибку, которая обрабатывается клиентским приложением.

Понятие оптимистического одновременного конкурентного доступа 
обычно определяется в более широком смысле. 
Работа управления оптимистического одновременного конкурентного доступа 
основана на предположении маловероятности конфликтов между несколькими пользователями, 
поэтому разрешается исполнение транзакций без установки блокировок. 
Только когда пользователь пытается изменить данные, выполняется проверка ресурсов,
чтобы определить наличие конфликтов.
Если таковые возникли, то приложение требуется перезапустить.

---

### Транзакции в T-SQL

Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, 
при этом в базе данных все внесенные изменения фиксируются на постоянной основе, или отменяются, 
т.е. все изменения, внесенные любой командой, входящей в транзакцию, будут отменены. 
Другими словами, если одна команда или инструкция внутри транзакции завершилась с ошибкой, то все, 
что было отработано перед ней, также отменяется, даже если предыдущие команды завершились успешно.

Транзакции очень полезны и просто незаменимы в тех случаях, когда вам необходимо реализовывать 
бизнес логику в базе данных Microsoft SQL Server, которая предполагает многошаговые операции, 
где каждый шаг логически связан с другими шагами.

По сути каждая отдельная инструкция языка T-SQL является транзакцией, это называется 
«Автоматическое принятие транзакций» или «Неявные транзакции», но также есть и явные транзакции, 
это когда мы сами явно начинаем транзакцию и также явно заканчиваем ее, т.е. делаем все это с помощью специальных команд.

Чтобы понять, как работают транзакции и для чего они нужны, давайте рассмотрим классический пример, 
который наглядно показывает необходимость использования транзакций.

Допустим, у вас есть хранимая процедура, которая осуществляет перевод средств с одного счета на другой, 
соответственно, как минимум у вас будет две операции в этой процедуре, снятие средств, 
и зачисление средств, например, две инструкции UPDATE.

Но в каждой из этих операций может возникнуть ошибка и инструкция не выполнится. 
А теперь представьте, что первая инструкция снимает деньги, она выполнилась успешно, 
вторая инструкция зачисляет деньги и в ней возникла ошибка, без транзакции снятые деньги просто потеряются, 
так как они никуда не будут зачислены.

Чтобы этого не допустить, все SQL инструкции, которые логически что-то объединяет, 
в данном случае все операции, связанные с переводом средств, пишут внутри транзакции, и тогда, 
если наступит подобная ситуация, все изменения будут отменены, т.е. деньги вернутся обратно на счет.

Транзакции можно сочетать с обработкой и перехватом ошибок TRY…CATCH, иными словами, 
вы отслеживаете ошибки в вашем блоке инструкций и если они появляются, то в блоке CATCH вы откатываете транзакцию, 
т.е. отменяете все изменения, которые были успешно выполнены до возникновения ошибки в транзакции.

Транзакции – это отличный механизм обеспечения целостности данных.

---

### Использование транзакций

Транзакция задает последовательность инструкций языка Transact-SQL, 
применяемую программистами базы данных для объединения в один пакет операций чтения и записи для того, 
чтобы система базы данных могла обеспечить согласованность данных. 

Существует два типа транзакций:

* Неявная транзакция - задает любую отдельную инструкцию INSERT, UPDATE или DELETE как единицу транзакции.

* Явная транзакция - обычно это группа инструкций языка Transact-SQL, начало и конец которой обозначаются такими инструкциями, как BEGIN TRANSACTION, COMMIT и ROLLBACK.

Понятие транзакции лучше всего объяснить на примере. 
Допустим, в базе данных SampleDb сотруднику "Василий Фролов" требуется присвоить новый табельный номер.
Этот номер нужно одновременно изменить в двух разных таблицах. 
В частности, требуется одновременно изменить строку в таблице Employee и соответствующие строки в таблице Works_on. 
Если обновить данные только в одной из этих таблиц, данные базы данных SampleDb будут несогласованны,
поскольку значения первичного ключа в таблице Employee
и соответствующие значения внешнего ключа в таблице Works_on не будут совпадать. 

Реализация этой транзакции посредством инструкций языка Transact-SQL показана в примере ниже:
```sql
USE SampleDb;

-- Начало транзакции
BEGIN TRANSACTION
    UPDATE Employee
        SET Id = 14568
        WHERE Id = 10102

    IF (@@error <> 0)
        -- Отменить транзакцию, если есть ошибки
        ROLLBACK
    
    UPDATE Works_on
        SET EmpId = 14568
        WHERE EmpId = 10102
    
    IF (@@error <> 0)
        ROLLBACK
-- Завершение транзакции
COMMIT
```

Согласованность данных, обрабатываемых в примере, можно обеспечить лишь в том случае,
если выполнены обе инструкции UPDATE либо обе не выполнены. 
Успех выполнения каждой инструкции UPDATE проверяется посредством глобальной переменной @@error. 
В случае ошибки этой переменной присваивается отрицательное значение 
и выполняется откат всех выполненных на данный момент инструкций транзакции.

---

### Свойства транзакции (ACID-свойства)

У транзакции есть 4 очень важных свойства:

* Атомарность (atomicity) – все команды в транзакции либо полностью выполняются, и соответственно, 
  фиксируются все изменения данных, либо ничего не выполняется и ничего не фиксируется;
  
* Согласованность (consistency) – данные, в случае успешного выполнения транзакции,
  должны соблюдать все установленные правила в части различных ограничений, первичных и внешних ключей, определенных в базе данных;
  
* Изоляция (isolation) – механизм предоставления доступа к данным.
  Транзакция изолирует данные, с которыми она работает, для того чтобы другие транзакции получали только согласованные данные;
  
* Надежность (durability) – все внесенные изменения фиксируются в журнале транзакций и данные считаются надежными,
  если транзакция была успешно завершена. В случае сбоя SQL Server сверяет данные, записанные в базе данных,
  с журналом транзакций, если есть успешно завершенные транзакции, которые не закончили процесс записи всех
  изменений в базу данных, они будут выполнены повторно. Все действия, выполненные не подтвержденными транзакциями, отменяются.

---

### Команды управления транзакциями в T-SQL

В T-SQL для управления транзакциями существуют следующие основные команды:

* BEGIN TRANSACTION (можно использовать сокращённую запись BEGIN TRAN) – 
  команда служит для определения начала транзакции.
  В качестве параметра этой команде можно передать и название транзакции, полезно, если у Вас есть вложенные транзакции;
  
* COMMIT TRANSACTION (можно использовать сокращённую запись COMMIT TRAN) –
  с помощью данной команды мы сообщаем SQL серверу об успешном завершении транзакции,
  и о том, что все изменения, которые были выполнены, необходимо сохранить на постоянной основе;
  
* ROLLBACK TRANSACTION (можно использовать сокращённую запись ROLLBACK TRAN) –
  служит для отмены всех изменений, которые были внесены в процессе выполнения транзакции,
  например, в случае ошибки, мы откатываем все назад;
  
* SAVE TRANSACTION (можно использовать сокращённую запись SAVE TRAN) –
  данная команда устанавливает промежуточную точку сохранения внутри транзакции,
  к которой можно откатиться, в случае возникновения необходимости.

---

### Простой пример транзакции в T-SQL

В данном примере у нас всего две инструкции, которые изменяют данные, но допустим, 
что они взаимосвязаны, т.е. они обе обязательно должны выполниться вместе или не выполниться также вместе.

Поэтому мы решили эти инструкции объединить в одну транзакцию.

Сначала мы открываем транзакцию командой BEGIN TRANSACTION, 
далее пишем все необходимые инструкции, которые мы хотим объединить в транзакцию.

После этого командой COMMIT TRANSACTION мы сохраняем все внесенные изменения.

В данном случае у нас нет никаких ошибок, все инструкции выполнились успешно. 
Как результат, транзакция завершена также успешно и все изменения сохранены на постоянной основе командой COMMIT TRANSACTION.
   
```sql
   BEGIN TRANSACTION

   --Инструкция 1
   UPDATE Goods SET Price = 70
   WHERE ProductId = 1;

   --Инструкция 2
   UPDATE Goods SET Price = 40
   WHERE ProductId = 2;

   COMMIT TRANSACTION

   SELECT ProductId, ProductName, Price
   FROM Goods;
```

Однако, если в любой из инструкций возникнет ошибка, транзакция не завершится, и все изменения не сохранятся.

При этом, стоит помнить о том, что ошибки с определённым уровнем серьезности, 
например, ошибки, связанные с нарушением ограничений, не влекут за собой 
автоматический откат всех изменений внесенных текущей транзакцией, 
поэтому всегда необходимо использовать или инструкцию SET XACT_ABORT ON,
или обработку ошибок (допускается и совместное использование).

Например, если во второй инструкции мы попытаемся записать в столбец Price какое-нибудь текстовое значение, 
то у нас возникнет ошибка, и изменения, внесённые первой инструкцией, не зафиксируются на постоянной основе.

---

### Пример транзакции в T-SQL с обработкой ошибок

В языке T-SQL существует механизм перехвата и обработки ошибок – конструкция TRY… CATCH.

Эту конструкцию можно использовать для отслеживания появления возможных ошибок
внутри транзакции и в случае появления таких ошибок предпринять определенные действия.

Сначала мы открываем блок для обработки ошибок, затем открываем транзакцию 
командой BEGIN TRANSACTION, далее пишем наши инструкции, например, те же самые две инструкции UPDATE.

После этого закрываем блок TRY, открываем блок CATCH, в котором в случае возникновения ошибки
мы откатываем все изменения командой ROLLBACK TRANSACTION. 
Также мы принудительно завершаем нашу инструкцию командой RETURN.

Если ошибок нет, то в блок CATCH мы, соответственно, не попадаем 
и у нас выполнится команда COMMIT TRANSACTION, которая сохранит все изменения.

В этом примере нет ошибок, поэтому транзакция завершена успешно.

 ```sql
   BEGIN TRY
   --Начало транзакции
   BEGIN TRANSACTION

   --Инструкция 1
   UPDATE Goods SET Price = 70
   WHERE ProductId = 1;

   --Инструкция 2
   UPDATE Goods SET Price = 40
   WHERE ProductId = 2;

   END TRY
   BEGIN CATCH
      --В случае непредвиденной ошибки
      --Откат транзакции
      ROLLBACK TRANSACTION

      --Выводим сообщение об ошибке
      SELECT ERROR_NUMBER() AS [Номер ошибки],
             ERROR_MESSAGE() AS [Описание ошибки]

   --Прекращаем выполнение инструкции
   RETURN

   END CATCH

   --Если все хорошо. Сохраняем все изменения
   COMMIT TRANSACTION

   GO

   SELECT ProductId, ProductName, Price
   FROM Goods;
```

Если намерено допустить ошибку в какой-нибудь инструкции,
управление передастся в блок CATCH, где мы откатываем все изменения, 
возвращаем номер и описание ошибки и принудительно завершаем всю инструкцию командой RETURN.



