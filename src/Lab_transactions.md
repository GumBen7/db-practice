---
title: Лабораторная работа. Транзакции в T-SQL
---

[К списку лабораторных >>>](../README.md)

---

### Задания

1. Создать транзакцию.
2. Произвести ее откат и фиксацию.
3. Показать, что данные:
  * существовали до отката,
  * удалились после отката,
  * снова были добавлены,
  * и затем были успешно зафиксированы.
4. Создать транзакцию в T-SQL с обработкой ошибок. Продемонстрировать случаи успешного и неуспешного завершения транзакций
5. Операторы, неявно завершающие транзакцию

---

### Транзакции в T-SQL

Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, 
при этом в базе данных все внесенные изменения фиксируются на постоянной основе, или отменяются, 
т.е. все изменения, внесенные любой командой, входящей в транзакцию, будут отменены. 
Другими словами, если одна команда или инструкция внутри транзакции завершилась с ошибкой, то все, 
что было отработано перед ней, также отменяется, даже если предыдущие команды завершились успешно.

Транзакции очень полезны и просто незаменимы в тех случаях, когда вам необходимо реализовывать 
бизнес логику в базе данных Microsoft SQL Server, которая предполагает многошаговые операции, 
где каждый шаг логически связан с другими шагами.

По сути каждая отдельная инструкция языка T-SQL является транзакцией, это называется 
«Автоматическое принятие транзакций» или «Неявные транзакции», но также есть и явные транзакции, 
это когда мы сами явно начинаем транзакцию и также явно заканчиваем ее, т.е. делаем все это с помощью специальных команд.

Чтобы понять, как работают транзакции и для чего они нужны, давайте рассмотрим классический пример, 
который наглядно показывает необходимость использования транзакций.

Допустим, у вас есть хранимая процедура, которая осуществляет перевод средств с одного счета на другой, 
соответственно, как минимум у вас будет две операции в этой процедуре, снятие средств, 
и зачисление средств, например, две инструкции UPDATE.

Но в каждой из этих операций может возникнуть ошибка и инструкция не выполнится. 
А теперь представьте, что первая инструкция снимает деньги, она выполнилась успешно, 
вторая инструкция зачисляет деньги и в ней возникла ошибка, без транзакции снятые деньги просто потеряются, 
так как они никуда не будут зачислены.

Чтобы этого не допустить, все SQL инструкции, которые логически что-то объединяет, 
в данном случае все операции, связанные с переводом средств, пишут внутри транзакции, и тогда, 
если наступит подобная ситуация, все изменения будут отменены, т.е. деньги вернутся обратно на счет.

Транзакции можно сочетать с обработкой и перехватом ошибок TRY…CATCH, иными словами, 
вы отслеживаете ошибки в вашем блоке инструкций и если они появляются, то в блоке CATCH вы откатываете транзакцию, 
т.е. отменяете все изменения, которые были успешно выполнены до возникновения ошибки в транзакции.

Транзакции – это отличный механизм обеспечения целостности данных.

---

### Свойства транзакции (ACID-свойства транзакций)

У транзакции есть 4 очень важных свойства:

* Атомарность (atomicity) – все команды в транзакции либо полностью выполняются, и соответственно, 
  фиксируются все изменения данных, либо ничего не выполняется и ничего не фиксируется;
  
* Согласованность (consistency) – данные, в случае успешного выполнения транзакции,
  должны соблюдать все установленные правила в части различных ограничений, первичных и внешних ключей, определенных в базе данных;
  
* Изоляция (isolation) – механизм предоставления доступа к данным.
  Транзакция изолирует данные, с которыми она работает, для того чтобы другие транзакции получали только согласованные данные;
  
* Надежность (durability) – все внесенные изменения фиксируются в журнале транзакций и данные считаются надежными,
  если транзакция была успешно завершена. В случае сбоя SQL Server сверяет данные, записанные в базе данных,
  с журналом транзакций, если есть успешно завершенные транзакции, которые не закончили процесс записи всех
  изменений в базу данных, они будут выполнены повторно. Все действия, выполненные не подтвержденными транзакциями, отменяются.

---

### Команды управления транзакциями в T-SQL

В T-SQL для управления транзакциями существуют следующие основные команды:

* BEGIN TRANSACTION (можно использовать сокращённую запись BEGIN TRAN) – 
  команда служит для определения начала транзакции.
  В качестве параметра этой команде можно передать и название транзакции, полезно, если у Вас есть вложенные транзакции;
  
* COMMIT TRANSACTION (можно использовать сокращённую запись COMMIT TRAN) –
  с помощью данной команды мы сообщаем SQL серверу об успешном завершении транзакции,
  и о том, что все изменения, которые были выполнены, необходимо сохранить на постоянной основе;
  
* ROLLBACK TRANSACTION (можно использовать сокращённую запись ROLLBACK TRAN) –
  служит для отмены всех изменений, которые были внесены в процессе выполнения транзакции,
  например, в случае ошибки, мы откатываем все назад;
  
* SAVE TRANSACTION (можно использовать сокращённую запись SAVE TRAN) –
  данная команда устанавливает промежуточную точку сохранения внутри транзакции,
  к которой можно откатиться, в случае возникновения необходимости.

---

### Простой пример транзакции в T-SQL

В данном примере у нас всего две инструкции, которые изменяют данные, но допустим, 
что они взаимосвязаны, т.е. они обе обязательно должны выполниться вместе или не выполниться также вместе.

Поэтому мы решили эти инструкции объединить в одну транзакцию.

Сначала мы открываем транзакцию командой BEGIN TRANSACTION, 
далее пишем все необходимые инструкции, которые мы хотим объединить в транзакцию.

После этого командой COMMIT TRANSACTION мы сохраняем все внесенные изменения.

В данном случае у нас нет никаких ошибок, все инструкции выполнились успешно. 
Как результат, транзакция завершена также успешно и все изменения сохранены на постоянной основе командой COMMIT TRANSACTION.
   
```sql
   BEGIN TRANSACTION

   --Инструкция 1
   UPDATE Goods SET Price = 70
   WHERE ProductId = 1;

   --Инструкция 2
   UPDATE Goods SET Price = 40
   WHERE ProductId = 2;

   COMMIT TRANSACTION

   SELECT ProductId, ProductName, Price
   FROM Goods;
```

Однако, если в любой из инструкций возникнет ошибка, транзакция не завершится, и все изменения не сохранятся.

При этом, стоит помнить о том, что ошибки с определённым уровнем серьезности, 
например, ошибки, связанные с нарушением ограничений, не влекут за собой 
автоматический откат всех изменений внесенных текущей транзакцией, 
поэтому всегда необходимо использовать или инструкцию SET XACT_ABORT ON,
или обработку ошибок (допускается и совместное использование).

Например, если во второй инструкции мы попытаемся записать в столбец Price какое-нибудь текстовое значение, 
то у нас возникнет ошибка, и изменения, внесённые первой инструкцией, не зафиксируются на постоянной основе.

---

### Пример транзакции в T-SQL с обработкой ошибок

В языке T-SQL существует механизм перехвата и обработки ошибок – конструкция TRY… CATCH.

Эту конструкцию можно использовать для отслеживания появления возможных ошибок
внутри транзакции и в случае появления таких ошибок предпринять определенные действия.

Сначала мы открываем блок для обработки ошибок, затем открываем транзакцию 
командой BEGIN TRANSACTION, далее пишем наши инструкции, например, те же самые две инструкции UPDATE.

После этого закрываем блок TRY, открываем блок CATCH, в котором в случае возникновения ошибки
мы откатываем все изменения командой ROLLBACK TRANSACTION. 
Также мы принудительно завершаем нашу инструкцию командой RETURN.

Если ошибок нет, то в блок CATCH мы, соответственно, не попадаем 
и у нас выполнится команда COMMIT TRANSACTION, которая сохранит все изменения.

В этом примере нет ошибок, поэтому транзакция завершена успешно.

 ```sql
   BEGIN TRY
   --Начало транзакции
   BEGIN TRANSACTION

   --Инструкция 1
   UPDATE Goods SET Price = 70
   WHERE ProductId = 1;

   --Инструкция 2
   UPDATE Goods SET Price = 40
   WHERE ProductId = 2;

   END TRY
   BEGIN CATCH
      --В случае непредвиденной ошибки
      --Откат транзакции
      ROLLBACK TRANSACTION

      --Выводим сообщение об ошибке
      SELECT ERROR_NUMBER() AS [Номер ошибки],
             ERROR_MESSAGE() AS [Описание ошибки]

   --Прекращаем выполнение инструкции
   RETURN

   END CATCH

   --Если все хорошо. Сохраняем все изменения
   COMMIT TRANSACTION

   GO

   SELECT ProductId, ProductName, Price
   FROM Goods;
```

Если намерено допустить ошибку в какой-нибудь инструкции,
управление передастся в блок CATCH, где мы откатываем все изменения, 
возвращаем номер и описание ошибки и принудительно завершаем всю инструкцию командой RETURN.



