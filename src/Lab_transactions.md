---
title: Лабораторная работа. Транзакции в T-SQL
---

[К списку лабораторных >>>](../README.md)

---

### Задания

1. Создать транзакцию.
2. Произвести ее откат и фиксацию.
3. Показать, что данные:
  * существовали до отката,
  * удалились после отката,
  * снова были добавлены,
  * и затем были успешно зафиксированы.
4. Создать транзакцию в T-SQL с обработкой ошибок. Продемонстрировать случаи успешного и неуспешного завершения транзакций
5. Создать пример транзакции с операторами, неявно завершающими транзакцию

---

### Проблема конкурентного доступа

Данные в базе данных обычно используются совместно 
многими прикладными пользовательскими программами (приложениями). 

Ситуация, когда несколько прикладных пользовательских программ одновременно
выполняют операции чтения и записи одних и тех же данных,
называется одновременным конкурентным (параллельным) доступом (concurrency). 

Таким образом, каждая система управления базами данных должна обладать
каким-либо типом механизма управления для решения проблем,
возникающих вследствие одновременного конкурентного доступа.

В системе баз данных, которая может обслуживать большое число
активных пользовательских приложений таким образом, чтобы эти приложения не мешали друг другу,
возможен высокий уровень одновременного конкурентного доступа.

И наоборот, система баз данных, в которой разные активные приложения мешают друг другу, 
поддерживает низкий уровень одновременного конкурентного доступа.

---

### Модели одновременного конкурентного доступа

Компонент Database Engine поддерживает две разные модели одновременного конкурентного доступа:

* пессимистический одновременный конкурентный доступ;
* оптимистический одновременный конкурентный доступ.

В модели пессимистического одновременного конкурентного доступа для предотвращения 
одновременного доступа к данным, которые используются другим процессом, применяются блокировки. 
Иными словами, система баз данных, использующая модель пессимистического одновременного конкурентного доступа, 
предполагает, что между двумя или большим количеством процессов в любое время может возникнуть конфликт
и поэтому блокирует ресурсы (строку, страницу, таблицу), как только они потребуются в течение периода транзакции. 
Модель пессимистического одновременного конкурентного доступа устанавливает блокировку 
с обеспечением разделяемого доступа, иначе немонопольную блокировку (shared lock) 
на считываемые данные, чтобы никакой другой процесс не мог изменить эти данные. 
Кроме этого, механизм пессимистического одновременного конкурентного доступа 
устанавливает монопольную блокировку (exclusive lock) на изменяемые данные,
чтобы никакой другой процесс не мог их считывать или модифицировать.

Работа оптимистического одновременного конкурентного доступа основана
на предположении маловероятности изменения данных одной транзакцией одновременно с другой.
Компонент Database Engine применяет оптимистический одновременный конкурентный доступ, 
при котором сохраняются старые версии строк, и любой процесс при чтении данных
использует ту версию строки, которая была активной, когда он начал чтение.
Поэтому процесс может модифицировать данные без каких-либо ограничений, 
поскольку все другие процессы, которые считывают эти же данные,
используют свою собственную сохраненную версию. 

Конфликтная ситуация возможна только при попытке двух операций записи 
использовать одни и те же данные. 
В таком случае система выдает ошибку, которая обрабатывается клиентским приложением.

Понятие оптимистического одновременного конкурентного доступа 
обычно определяется в более широком смысле. 
Работа управления оптимистического одновременного конкурентного доступа 
основана на предположении маловероятности конфликтов между несколькими пользователями, 
поэтому разрешается исполнение транзакций без установки блокировок. 
Только когда пользователь пытается изменить данные, выполняется проверка ресурсов,
чтобы определить наличие конфликтов.
Если таковые возникли, то приложение требуется перезапустить.

---

### Транзакции в T-SQL

Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, 
при этом в базе данных все внесенные изменения фиксируются на постоянной основе, или отменяются, 
т.е. все изменения, внесенные любой командой, входящей в транзакцию, будут отменены. 
Другими словами, если одна команда или инструкция внутри транзакции завершилась с ошибкой, то все, 
что было отработано перед ней, также отменяется, даже если предыдущие команды завершились успешно.

Транзакции очень полезны и просто незаменимы в тех случаях, когда вам необходимо реализовывать 
бизнес логику в базе данных Microsoft SQL Server, которая предполагает многошаговые операции, 
где каждый шаг логически связан с другими шагами.

По сути каждая отдельная инструкция языка T-SQL является транзакцией, это называется 
«Автоматическое принятие транзакций» или «Неявные транзакции», но также есть и явные транзакции, 
это когда мы сами явно начинаем транзакцию и также явно заканчиваем ее, т.е. делаем все это с помощью специальных команд.

Чтобы понять, как работают транзакции и для чего они нужны, давайте рассмотрим классический пример, 
который наглядно показывает необходимость использования транзакций.

Допустим, у вас есть хранимая процедура, которая осуществляет перевод средств с одного счета на другой, 
соответственно, как минимум у вас будет две операции в этой процедуре, снятие средств, 
и зачисление средств, например, две инструкции UPDATE.

Но в каждой из этих операций может возникнуть ошибка и инструкция не выполнится. 
А теперь представьте, что первая инструкция снимает деньги, она выполнилась успешно, 
вторая инструкция зачисляет деньги и в ней возникла ошибка, без транзакции снятые деньги просто потеряются, 
так как они никуда не будут зачислены.

Чтобы этого не допустить, все SQL инструкции, которые логически что-то объединяет, 
в данном случае все операции, связанные с переводом средств, пишут внутри транзакции, и тогда, 
если наступит подобная ситуация, все изменения будут отменены, т.е. деньги вернутся обратно на счет.

Транзакции можно сочетать с обработкой и перехватом ошибок TRY…CATCH, иными словами, 
вы отслеживаете ошибки в вашем блоке инструкций и если они появляются, то в блоке CATCH вы откатываете транзакцию, 
т.е. отменяете все изменения, которые были успешно выполнены до возникновения ошибки в транзакции.

Транзакции – это отличный механизм обеспечения целостности данных.

---

### Использование транзакций

Транзакция задает последовательность инструкций языка Transact-SQL, 
применяемую программистами базы данных для объединения в один пакет операций чтения и записи для того, 
чтобы система базы данных могла обеспечить согласованность данных. 

Существует два типа транзакций:

* Неявная транзакция - задает любую отдельную инструкцию INSERT, UPDATE или DELETE как единицу транзакции.

* Явная транзакция - обычно это группа инструкций языка Transact-SQL, начало и конец которой обозначаются такими инструкциями, как BEGIN TRANSACTION, COMMIT и ROLLBACK.

Понятие транзакции лучше всего объяснить на примере. 
Допустим, в базе данных SampleDb сотруднику "Василий Фролов" требуется присвоить новый табельный номер.
Этот номер нужно одновременно изменить в двух разных таблицах. 
В частности, требуется одновременно изменить строку в таблице Employee и соответствующие строки в таблице Works_on. 
Если обновить данные только в одной из этих таблиц, данные базы данных SampleDb будут несогласованны,
поскольку значения первичного ключа в таблице Employee
и соответствующие значения внешнего ключа в таблице Works_on не будут совпадать. 

Реализация этой транзакции посредством инструкций языка Transact-SQL показана в примере ниже:
```sql
USE SampleDb;

-- Начало транзакции
BEGIN TRANSACTION
    UPDATE Employee
        SET Id = 14568
        WHERE Id = 10102

    IF (@@error <> 0)
        -- Отменить транзакцию, если есть ошибки
        ROLLBACK
    
    UPDATE Works_on
        SET EmpId = 14568
        WHERE EmpId = 10102
    
    IF (@@error <> 0)
        ROLLBACK
-- Завершение транзакции
COMMIT
```

Согласованность данных, обрабатываемых в примере, можно обеспечить лишь в том случае,
если выполнены обе инструкции UPDATE либо обе не выполнены. 
Успех выполнения каждой инструкции UPDATE проверяется посредством глобальной переменной @@error. 
В случае ошибки этой переменной присваивается отрицательное значение 
и выполняется откат всех выполненных на данный момент инструкций транзакции.

---

### Свойства транзакции (ACID-свойства)

У транзакции есть 4 очень важных свойства:

* Атомарность (atomicity) – все команды в транзакции либо полностью выполняются, и соответственно, 
  фиксируются все изменения данных, либо ничего не выполняется и ничего не фиксируется;
  
* Согласованность (consistency) – данные, в случае успешного выполнения транзакции,
  должны соблюдать все установленные правила в части различных ограничений, первичных и внешних ключей, определенных в базе данных;
  
* Изоляция (isolation) – механизм предоставления доступа к данным.
  Транзакция изолирует данные, с которыми она работает, для того чтобы другие транзакции получали только согласованные данные;
  
* Надежность (durability) – все внесенные изменения фиксируются в журнале транзакций и данные считаются надежными,
  если транзакция была успешно завершена. В случае сбоя SQL Server сверяет данные, записанные в базе данных,
  с журналом транзакций, если есть успешно завершенные транзакции, которые не закончили процесс записи всех
  изменений в базу данных, они будут выполнены повторно. Все действия, выполненные не подтвержденными транзакциями, отменяются.

---

### Команды управления транзакциями в T-SQL

В T-SQL для управления транзакциями существуют следующие основные команды:

#### BEGIN TRANSACTION (можно использовать сокращённую запись BEGIN TRAN) 

–  команда служит для определения начала транзакции.

В качестве параметра этой команде можно передать и название транзакции, полезно, если у Вас есть вложенные транзакции;

Синтаксис этой инструкции выглядит следующим образом:
```sql
BEGIN TRANSACTION [ {transaction_name | @trans_var }
    [WITH MARK ['description']]]
```

В параметре transaction_name указывается имя транзакции, которое можно использовать 
только в самой внешней паре вложенных инструкций BEGIN TRANSACTION/COMMIT или BEGIN TRANSACTION/ROLLBACK. 
В параметре @trans_var указывается имя определяемой пользователем переменной, 
содержащей действительное имя транзакции.

Параметр WITH MARK указывает, что транзакция должна быть отмечена в журнале. 

Аргумент description - это строка, описывающая эту отметку. 

В случае использования параметра WITH MARK требуется указать имя транзакции.

Инструкция BEGIN DISTRIBUTED TRANSACTION запускает распределенную транзакцию, 

которая управляется Microsoft Distributed Transaction Coordinator 
(MS DTC - координатором распределенных транзакций Microsoft).

Распределенная транзакция - это транзакция, которая используется
на нескольких базах данных и на нескольких серверах. 
Поэтому для таких транзакций требуется координатор для согласования выполнения 
инструкций на всех вовлеченных серверах. 
Координатором распределенной транзакции является сервер, 
запустивший инструкцию BEGIN DISTRIBUTED TRANSACTION, 
и поэтому он и управляет выполнением распределенной транзакции.
  
#### COMMIT TRANSACTION / COMMIT WORK (можно использовать сокращённую запись COMMIT TRAN) 

–  с помощью данной команды мы сообщаем SQL серверу об успешном завершении транзакции,
и о том, что все изменения, которые были выполнены, необходимо сохранить на постоянной основе;

Инструкция COMMIT WORK так же успешно завершает транзакцию, запущенную инструкцией BEGIN TRANSACTION.
Это означает, что все выполненные транзакцией изменения фиксируются и сохраняются на диск.
Инструкция COMMIT WORK является стандартной формой этой инструкции. 
Использовать предложение WORK не обязательно.

COMMIT TRANSACTION  функционально равнозначна инструкции COMMIT WORK, 
с той разницей, что она принимает определяемое пользователем имя транзакции.

#### ROLLBACK TRANSACTION / ROLLBACK WORK (можно использовать сокращённую запись ROLLBACK TRAN) 

–  служит для отмены всех изменений, которые были внесены в процессе выполнения транзакции,
например, в случае ошибки, мы откатываем все назад;

Инструкция ROOLBACK WORK сообщает о неуспешном выполнении транзакции. 
Программисты используют эту инструкцию, когда они полагают, 
что база данных может оказаться в несогласованном состоянии. 
В таком случае выполняется откат всех произведенных инструкциями транзакции изменений. 
Инструкция ROOLBACK WORK является стандартной формой этой инструкции. 
Использовать предложение WORK не обязательно. Язык Transact-SQL также поддерживает
инструкцию ROLLBACK TRANSACTION, которая функционально равнозначна инструкции ROOLBACK WORK, 
с той разницей, что она принимает определяемое пользователем имя транзакции.
  
#### SAVE TRANSACTION (можно использовать сокращённую запись SAVE TRAN)

– данная команда устанавливает промежуточную точку сохранения внутри транзакции,
к которой можно откатиться, в случае возникновения необходимости.

Инструкция SAVE TRANSACTION устанавливает точку сохранения внутри транзакции. 
Точка сохранения (savepoint) определяет заданную точку в транзакции, 
так что все последующие изменения данных могут быть отменены без отмены всей транзакции. 
(Для отмены всей транзакции применяется инструкция ROLLBACK.) 
Инструкция SAVE TRANSACTION в действительности не фиксирует никаких выполненных изменений данных.
Она только создает метку для последующей инструкции ROLLBACK,
имеющей такую же метку, как и данная инструкция SAVE TRANSACTION.

Инструкция SAVE TRANSACTION в сочетании с инструкцией IF или WHILE является полезной возможностью,
позволяющей выполнять отдельные части всей транзакции. 
С другой стороны, использование этой инструкции противоречит принципу работы с базами данных, 
гласящему, что транзакция должна быть минимальной длины,
поскольку длинные транзакции обычно уменьшают уровень доступности данных.

---

### Неявные транзакции

Как вы уже знаете, каждая инструкция Transact-SQL всегда явно или неявно принадлежит к транзакции. 
Для удовлетворения требований стандарта SQL компонент Database Engine предоставляет поддержку неявных транзакций. 
Когда сеанс работает в режиме неявных транзакций, выполняемые инструкции неявно выдают инструкции BEGIN TRANSACTION. 
Это означает, что для того чтобы начать неявную транзакцию, пользователю или разработчику не требуется ничего делать. 
Но каждую неявную транзакцию нужно или явно зафиксировать или явно отменить, 
используя инструкции COMMIT или ROLLBACK соответственно. 
Если транзакцию явно не зафиксировать, то все изменения, выполненные в ней, откатываются при отключении пользователя.

Для разрешения неявных транзакций параметру implicit_transactions оператора SET
необходимо присвоить значение ON. 
Это установит режим неявных транзакций для текущего сеанса. 
Когда для соединения установлен режим неявных транзакций и соединение в данный момент
не используется в транзакции, выполнение любой из следующих инструкций запускает транзакцию:

* ALTER TABLE;
* FETCH;
* REVOKE;
* CREATE TABLE;
* GRANT;
* SELECT;
* DELETE;
* INSERT;
* TRUNCATE TABLE;
* DROPTABLE;
* OPEN;
* UPDATE.

Иными словами, если имеется последовательность инструкций из предыдущего списка,
то каждая из этих инструкций будет представлять транзакцию.

Начало явной транзакции помечается инструкцией BEGIN TRANSACTION, 
а окончание - инструкцией COMMIT или ROLLBACK. Явные транзакции можно вкладывать друг в друга. 
В таком случае, каждая пара инструкций BEGIN TRANSACTION/COMMIT
или BEGIN TRANSACTION/ROLLBACK используется внутри каждой такой пары 
или большего количества вложенных транзакций. 
(Вложенные транзакции обычно используются в хранимых процедурах,
которые сами содержат транзакции и вызываются внутри другой транзакции.) 

Глобальная переменная @@trancount содержит число активных транзакций для текущего пользователя.

Инструкции BEGIN TRANSACTION, COMMIT и ROLLBACK могут использоваться с именем заданной транзакции. 
(Именованная инструкция ROLLBACK соответствует или именованной транзакции,
или инструкции SAVE TRANSACTION с таким же именем.)
Именованную транзакцию можно применять только в самой внешней паре вложенных инструкций
BEGIN TRANSACTON/COMMIT или BEGIN TRANSACTION/ROLLBACK.

---

### Простой пример транзакции в T-SQL

В данном примере у нас всего две инструкции, которые изменяют данные, но допустим, 
что они взаимосвязаны, т.е. они обе обязательно должны выполниться вместе или не выполниться также вместе.

Поэтому мы решили эти инструкции объединить в одну транзакцию.

Сначала мы открываем транзакцию командой BEGIN TRANSACTION, 
далее пишем все необходимые инструкции, которые мы хотим объединить в транзакцию.

После этого командой COMMIT TRANSACTION мы сохраняем все внесенные изменения.

В данном случае у нас нет никаких ошибок, все инструкции выполнились успешно. 
Как результат, транзакция завершена также успешно и все изменения сохранены на постоянной основе командой COMMIT TRANSACTION.
   
```sql
   BEGIN TRANSACTION

   --Инструкция 1
   UPDATE Goods SET Price = 70
   WHERE ProductId = 1;

   --Инструкция 2
   UPDATE Goods SET Price = 40
   WHERE ProductId = 2;

   COMMIT TRANSACTION

   SELECT ProductId, ProductName, Price
   FROM Goods;
```

Однако, если в любой из инструкций возникнет ошибка, транзакция не завершится, и все изменения не сохранятся.

При этом, стоит помнить о том, что ошибки с определённым уровнем серьезности, 
например, ошибки, связанные с нарушением ограничений, не влекут за собой 
автоматический откат всех изменений внесенных текущей транзакцией, 
поэтому всегда необходимо использовать или инструкцию SET XACT_ABORT ON,
или обработку ошибок (допускается и совместное использование).

Например, если во второй инструкции мы попытаемся записать в столбец Price какое-нибудь текстовое значение, 
то у нас возникнет ошибка, и изменения, внесённые первой инструкцией, не зафиксируются на постоянной основе.

---

### Пример транзакции с откатом

```sql
USE SampleDb;

BEGIN TRANSACTION;
    INSERT INTO Department (Number, DepartmentName)
        VALUES ('d4', 'Скидки');
    SAVE TRANSACTION a;

    INSERT INTO Department (Number, DepartmentName)
        VALUES ('d5', 'Исследование');
    SAVE TRANSACTION b;

    INSERT INTO Department (Number, DepartmentName)
        VALUES ('d6', 'Менеджмент');
    
    ROLLBACK TRANSACTION b;

    INSERT INTO Department (Number, DepartmentName)
        VALUES ('d7', 'Поддержка');

    ROLLBACK TRANSACTION a;

COMMIT TRANSACTION;
```

Единственной инструкцией, которая выполняется в этом примере, является первая инструкция INSERT. 
Для третьей инструкции INSERT выполняется откат с помощью инструкции ROLLBACK TRANSACTION b,
а для двух других инструкций INSERT будет выполнен откат инструкцией ROLLBACK TRANSACTION a.

---

### Пример транзакции с обработкой ошибок

В языке T-SQL существует механизм перехвата и обработки ошибок – конструкция TRY… CATCH.

Эту конструкцию можно использовать для отслеживания появления возможных ошибок
внутри транзакции и в случае появления таких ошибок предпринять определенные действия.

Сначала мы открываем блок для обработки ошибок, затем открываем транзакцию 
командой BEGIN TRANSACTION, далее пишем наши инструкции, например, те же самые две инструкции UPDATE.

После этого закрываем блок TRY, открываем блок CATCH, в котором в случае возникновения ошибки
мы откатываем все изменения командой ROLLBACK TRANSACTION. 
Также мы принудительно завершаем нашу инструкцию командой RETURN.

Если ошибок нет, то в блок CATCH мы, соответственно, не попадаем 
и у нас выполнится команда COMMIT TRANSACTION, которая сохранит все изменения.

В этом примере нет ошибок, поэтому транзакция завершена успешно.

 ```sql
   BEGIN TRY
   --Начало транзакции
   BEGIN TRANSACTION

   --Инструкция 1
   UPDATE Goods SET Price = 70
   WHERE ProductId = 1;

   --Инструкция 2
   UPDATE Goods SET Price = 40
   WHERE ProductId = 2;

   END TRY
   BEGIN CATCH
      --В случае непредвиденной ошибки
      --Откат транзакции
      ROLLBACK TRANSACTION

      --Выводим сообщение об ошибке
      SELECT ERROR_NUMBER() AS [Номер ошибки],
             ERROR_MESSAGE() AS [Описание ошибки]

   --Прекращаем выполнение инструкции
   RETURN

   END CATCH

   --Если все хорошо. Сохраняем все изменения
   COMMIT TRANSACTION

   GO

   SELECT ProductId, ProductName, Price
   FROM Goods;
```

Если намерено допустить ошибку в какой-нибудь инструкции,
управление передастся в блок CATCH, где мы откатываем все изменения, 
возвращаем номер и описание ошибки и принудительно завершаем всю инструкцию командой RETURN.

---

### Журнал транзакций

Реляционные системы баз данных создают запись для каждого изменения,
которые они выполняют в базе данных в процессе транзакции.
Это требуется на случай ошибки при выполнении транзакции.
В такой ситуации все выполненные инструкции транзакции необходимо отменить, осуществив для них откат. 
Как только система обнаруживает ошибку, она использует сохраненные записи, 
чтобы возвратить базу данных в согласованное состояние, в котором она была до начала выполнения транзакции.

Компонент Database Engine сохраняет все эти записи, в особенности значения до и после транзакции,
в одном или более файлов, которые называются журналами транзакций (transaction log).
Для каждой базы данных ведется ее собственный журнал транзакций.
Таким образом, если возникает необходимость отмены одной или нескольких операций изменения
данных в таблицах текущей базы данных, компонент Database Engine использует 
записи в журнале транзакций, чтобы восстановить значения столбцов таблиц, которые существовали до начала транзакции.

Журнал транзакций применяется для отката или восстановления транзакции. 
Если в процессе выполнения транзакции еще до ее завершения возникает ошибка, 
то система использует все существующие в журнале транзакций исходные значения записей
(которые называются исходными образами записей (before image)),
чтобы выполнить откат всех изменений, выполненных после начала транзакции.
Процесс, в котором исходные образы записей из журнала транзакций используются
для отката всех изменений, называется операцией отмены записей (undo activity).

В журналах транзакций также сохраняются преобразованные образы записей (after image). 
Преобразованные образы - это модифицированные значения, которые применяются для
отмены отката всех изменений, выполненных после старта транзакции. 
Этот процесс называется операцией повторного выполнения действий (redo activity) 
и применяется при восстановлении базы данных.

Каждой записи в журнале транзакций присваивается однозначный идентификатор,
называемый порядковым номером журнала транзакции (log sequence number - LSN).
Все записи журнала, являющиеся частью определенной транзакции, 
связаны друг с другом, чтобы можно было найти все части этой транзакции для операции отмены или повтора.

---
